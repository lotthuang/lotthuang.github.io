<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>第七篇 架构师思维和特质以及中间件技术梳理 - Lott's Blog</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u7b2c\u4e03\u7bc7 \u67b6\u6784\u5e08\u601d\u7ef4\u548c\u7279\u8d28\u4ee5\u53ca\u4e2d\u95f4\u4ef6\u6280\u672f\u68b3\u7406";
        var mkdocs_page_input_path = "chapter_2/jiagoushisiweihetezhi.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Lott's Blog
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">第一章 各种杂项基础</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/1_make_blog/">第一篇 利用Github Pages和mkdocs搭建个人博客</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/2_nginx_loadbalancing_strategy/">第二篇 Nginx的均衡策略</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/3_linux_kernel_basic/">第三篇 Linux内核基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/4_linux_kernel_mm_basic/">第四篇 Linux内核空间内存概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/5_how_kernel_call_bios/">第五篇 Linux内核调用BIOS案例</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/9_linux_arch_overall_introduction/">第九篇 Linux架构整体介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/10_virtual_machine_on_mac_m1_chip/">第十篇 Mac M1芯片电脑利用Qemu安装Debian虚拟机</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/11_nftables/">第十一篇 Debian 11以及往后版本nftables防火墙配置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/12_ansible_basic_use/">第十二篇 Ansible简单使用笔记</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/13_tty_terminal_console/">第十三篇 终端(Terminal)、TTY、PTY和控制台(Console)区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/14_qemu_use/">第十四篇 QEMU模拟各类开发板</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/15_bosun/">第十五篇 Bosun使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/16_assembler/">第十六篇 汇编语言使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/17_makefile/">第十七篇 Makefile使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/19_network_ratelimit/">第十九篇 Linux网络限速</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/20_mac_os_skills/">第二十篇 MacOS使用技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/21_debian_skills/">第二十一篇 Debian使用技巧</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第二章 运维工作总结</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../yunweijiazhi/">第一篇 运维的价值和目标</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../yunweizhiyeguifan/">第二篇 业务SRE的职业规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../yunweipingtailinian/">第三篇 运维平台建设的理念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../guzhangguanli/">第四篇 故障管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../biangengguanli/">第五篇 变更管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../rongliangguanli/">第六篇 容量管理概述</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">第七篇 架构师思维和特质以及中间件技术梳理</a>
    <ul class="current">
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../cicd/">第八篇 CICD流程概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../9_changkanchangxin/">第九篇 常看常新</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../12_monitor_and_alert/">第十二篇 监控报警最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../13_classic_thinkings/">第十三篇 经典思维</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../14_performance_optimization_topic/">第十四篇 性能优化专题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第三章 Linux Net子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/1_linux_kernel_net/">第一篇 Linux数据包接收路径梳理和常用调优技能</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/2_estab_queue_monitoring/">第二篇 Linux下如何观察完整连接队列的情况</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/3_net_ipv4_tcp_syn_retries/">第三篇 理解net.ipv4.tcp_syn_retries设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/4_linux_kernel_net_v2/">第四篇 Linux网络数据包的揭秘以及常见的调优方式总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/5_conntrack/">第五篇 conntrack的常见应用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/6_tcp/">第六篇 TCP协议总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/7_udp/">第七篇 UDP协议总结以及TCP和UDP的区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/8_io_multiplexing/">第八篇 IO多路复用总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/10_linux_net/">第十篇 Linux Net子系统总结、收发包流程再次梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/11_igb/">第十一篇 igb网卡驱动梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/12_rss_rps_rfs_xps/">第十二篇 Linux网卡rss和rps和rfs和xps</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/13_linghunkaowen/">第十三篇 Linux网络子系统灵魂拷问</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第四章 Linux CPU子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/1_process_ulimit/">第一篇 进程Max open files的设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/2_pid_max/">第二篇 kernel源码中pid的最大值</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/3_interrupt_one/">第三篇 硬中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/5_soft_irq/">第四篇 软中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/4_process_thread_coroutine/">第五篇 进程、线程、协程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/6_cpu_famous_register/">第六篇 CPU中的著名寄存器梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/7_linux_signal/">第七篇 Linux信号机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/8_linux_scheduler/">第八篇 Linux进程调度</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/10_linux_context_switch/">第十篇 低视角看context switch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/11_linux_cpu_usage/">第十一篇 CPU利用率统计</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/12_linux_preemption/">第十二篇 内核抢占基础篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/13_interrupt_handler_examples/">第十三篇 中断处理程序的例子</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/14_linux_kernel_tracing/">第十四篇 理解内核追踪机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/15_task_struct/">第十五篇 task_struct结构体总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/16_init_call/">第十六篇 Linux各类initcall总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/17_coredump/">第十七篇 Linux coredump总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第五章 Linux IO子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/1_four_object_of_VFS/">第一篇 VFS四大对象inode、dentry、super_block、file数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/2_io_stack/">第二篇 Linux IO栈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/3_zero_copy/">第三篇 Linux 零拷贝技术总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/4_io_scheduler_layer/">第四篇 Block IO Layer(块IO层)总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/6_fss/">第六篇 各类文件系统梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/7_three_object_of_block_device/">第七篇 块设备三大对象block_device、gendisk、hd_struct数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/8_kobjet_kset_ktype/">第八篇 Linux设备模型的基石:kset/kobject/ktype</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/9_io_uring/">第八篇 io_uring研究和总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第六章 Linux Mem子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/1_linux_buddy/">第一篇 伙伴系统介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/2_slab/">第二篇 Slab层介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/3_virtual_memory/">第三篇 进程虚拟地址空间介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/4_linux_mem_theory/">第四篇 Linux内存管理基础篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/6_alloc_mem_apis/">第六篇 Linux内核内存分配API函数分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/7_physical_memory/">第七篇 关于物理内存管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/8_linux_mm_update/">第八篇 Linux内存管理升级篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/9_page_cache_and_buffer_cache/">第九篇 PageCache和BufferCache演进过程</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第七章 运维小技巧和工具汇总和积累</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/1_sync_file/">第一篇 不同主机之间的文件传输</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/2_sre_tools_python/">第二篇 运维生产力工具(python篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/3_sre_tools_website/">第三篇 运维生产力工具(网站工具)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/4_sre_tools_shell/">第四篇 运维生产力工具(shell篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/5_server_side_evolution/">第五篇 服务端进化过程梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/6_elk/">第六篇 elk技术栈</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/7_charset/">第七篇 字符集和编码</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/8_locale/">第八篇 locale设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/9_http_protocol/">第九篇 http协议</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/10_http_cookie_session_token/">第十篇 cookie和session和token总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第八章 职场通用经验</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/1_xuexixinde/">第一篇 学习心得和工作箴言</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/2_bangzhuqitatongxue/">第二篇 工作能力评价体系</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/3_yewuliuchengshuyu/">第三篇 项目管理总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/4_jishunenglimoxing/">第四篇 技术能力模型总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/5_chanpingsiwei_1/">第五篇 产品思维总结和梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/6_jixiaobaogao/">第六篇 如何写绩效报告</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/7_xiangshangguanli/">第七篇 如何向上管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/9_speaking_skills/">第九篇 沟通能力和演讲技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/10_jixiaofangtan/">第十篇 绩效访谈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/11_classic_technical_thinking/">第十一篇 经典技术思维汇总</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第九章 编程经验和各类开源软件</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/1_suanfa/">第一篇 算法总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/2_data_structure/">第二篇 数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/3_c_lang/">第三篇 c语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/4_symbol_table/">第四篇 符号表总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/5_golang/">第五篇 go语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/6_linux_kernel_patch/">第六篇 手把手教你向Linux Kernel提交Patch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/7_python/">第七篇 python语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/8_rsyslog/">第八篇 rsyslog</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/9_falcon/">第九篇 falcon和夜莺</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/10_json_schema/">第十篇 JSON-Schema使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/11_prometheus/">第十一篇 Prometheus使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/12_grafana/">第十二篇 Grafana使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/13_mysql/">第十三篇 MySQL使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/14_mongodb/">第十四篇 MongoDB使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/15_supervisor/">第十五篇 Supervisor使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/16_redis/">第十六篇 Redis使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/17_mongodb_2/">第十七篇 MongoDB基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/18_elk_2/">第十八篇 ELK基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/19_gitlab_ce/">第十九篇 Gitlab-ce维护</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十章 容器化和Kubernetes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/1_dockerfile_best_practice/">第一篇 dockerfile最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/2_benefits_of_containerization/">第二篇 容器化好处</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/3_docker_basic_concepts/">第三篇 容器化基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/4_kubernetes_basic_concepts/">第四篇 Kubernetes基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/6_production_kubernetes_best_practice/">第六篇 生产环境Kubernetes部署最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/7_production_kerbernetes_yaml/">第七篇 生产环境Kubernetes YAML模版</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/8_caclio/">第八篇 Kubernetes网络插件之Caclio</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/9_cloudnative_monitor/">第九篇 云原生监控</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/10_event/">第十篇 彻底搞懂Kubernetes Event</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/11_best_practices/">第十一篇 Kubernetes最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/12_cloud_network/">第十二篇 云网络</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/13_containerd/">第十三篇 Containerd</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十一章 SRE稳定性建设从理论到实践</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/1_theory/">第一篇 稳定性概论</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/10_high_avaliable/">第二篇 高可用原则总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/2_slo_process/">第三篇 SLO实施流程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/3_stress/">第四篇 压测经验总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/11_stability/">第五篇 稳定性理论总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十二章 商业化知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_12/1_shifouzhide/">第一篇 如何判断一件事情值不值得做</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十三章 芯片知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_13/1_about_riscv/">第一篇 RISC-V 简介</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十四章 Linux驱动方向总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/1_demo_of_led_driver/">第一篇 驱动程序的Hello World</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/2_qianrushidev/">第二篇 嵌入式开发基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/3_linux_kernel_api_list/">第三篇 Linux内核API汇总和各类风格总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/4_zifushebeiqudongyuanli/">第四篇 字符设备驱动实现原理和物理内存地址空间和IO端口空间</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/5_device_tree/">第五篇 platform总线模型和设备树</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/6_device_driver_sop/">第六篇 从阅读硬件手册开始设备驱动程序编写</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/7_linux_kernel_clipping/">第七篇 Linux移植</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/8_linux_driver_framework/">第八篇 Linux驱动框架和SoC驱动框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/9_linux_device_class/">第九篇 Linux设备分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/10_u_boot/">第十篇 u-boot梳理和总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/11_linux_reset_subsystem_and_framework/">第十一篇 Linux Reset子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/12_pinctl_and_gpio/">第十二篇 Linux pinctl和gpio子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/13_embedded_development_direction/">第十三篇 嵌入式开发方向和分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/14_linux_kernel_trimming/">第十四篇 Linux内核裁剪总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/15_imx6ull/">第十五篇 IMX6UL实验记录</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十五章 AI+嵌入式结合方向汇总</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_15/1_demo_of_ai/">第一篇 AI程序 Hello World</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十六章 网络安全方向</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_16/1_network_attack/">第一篇 认识各种网络攻击</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Lott's Blog</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">第二章 运维工作总结</li>
      <li class="breadcrumb-item active">第七篇 架构师思维和特质以及中间件技术梳理</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">概述</h1>
<p><strong>这篇文章的目标</strong></p>
<ul>
<li>总结架构师必备的特质</li>
<li>梳理常见的架构思维</li>
<li>梳理常见的中间件技术</li>
</ul>
<h1 id="_2">架构师必备的特质</h1>
<ul>
<li>一名优秀的架构师，在设计系统时需要有以下这<a href="https://www.geek-share.com/detail/2794041054.html">四项关键能力</a>：「平衡取舍、预判未来、抽象思维、容错机制」</li>
<li>作为一名优秀的 SRE, 在设计技术方案时，也需要提升这四项关键能力.</li>
</ul>
<h2 id="_3">平衡取舍</h2>
<p>一个架构本质上总会有优有劣，它不可能是完美的、普适的，也不存在一个架构在 A 场景能用，在 B 场景也最适用的情况，所以就需要我们准确判断，作出取舍。
我们可以根据具体的业务需求来调整架构，也就是以当前的业务需求，选出最匹配的架构。另外，架构师还需要根据现状衡量好需求和资源、效率和安全、时延和吞吐等等之间的关系，做出判断。
比如对于在线交易系统，可能更重要的是保证它的低时延，因此就可以牺牲一定的吞吐量，而对于离线系统，吞吐量则更重要一些。</p>
<ul>
<li>满足业务需求的前提下，最大化 ROI.</li>
</ul>
<h2 id="_4">预判未来</h2>
<p>架构师需要具备一定的未来的预判能力，因为架构的调整周期通常比较长。这也是程序员和架构师之间一个很大的区别所在。
程序员负责一个项目，在当前的互联网大背景下，项目的迭代周期非常快，基本以天或周为单位，最多一个月。如果发现不合适的代码，需要重构，程序员基本也能在几天或几周内就能完成重构。
而架构的调整是相对漫长的过程，可能需要数月，甚至要几年。因此，在设计架构时就需要架构师具备预判意识，对很多不确定的事情做出预判和选择，诸如未来访问量会增长到什么量级，会不会产生新的业务，这些会对系统产生什么样新的要求等等。</p>
<ul>
<li>具备技术敏感度,预判业务未来走向.</li>
</ul>
<h2 id="_5">抽象思维</h2>
<p>除了懂得取舍和拥有预判意识，架构师在设计架构时还要掌握抽象的方法，不能胡子眉毛一把抓，要做好分层和区隔。
因为架构师面对的是一个很庞大的系统，为了避免过早陷入细节，不要去看各个组件的细节，而是把它们的角色定义下来之后，再分块来思考。而在看每个分块时，其他分块都可以视为一个抽象的概念，另外，也需要考虑复用的问题。</p>
<ul>
<li>这里很重要的一点就是想清楚目标，然后进行分层，设计好每一层作用、上下层之间的接口.</li>
</ul>
<h2 id="_6">容错机制</h2>
<p>相比程序员，架构师面对的环境要恶劣的多，因为系统更复杂了，出错的概率也增加了，每个节点、每个功能都有可能出错，所以这就需要架构师为错误而设计（Design For Failure），事先提前做好解决方案。</p>
<p>除了应用出错，还有可能产生数据丢失的情况，这个可以通过备份来预防。</p>
<p>另外，如果出现故障，该怎样做到快速恢复呢？我们现在普遍的做法是不修只换，因为如果要修复一个异常状态，可能修复后还会出现连带问题，而如果能通过技术手段，删除已出现的故障，换一个全新的系统，就能够保证它迅速恢复到正常状态。</p>
<ul>
<li>Design For Failure</li>
<li>故障预案</li>
</ul>
<h1 id="_7">一些优秀的架构思想</h1>
<p><strong>以下是一些做架构设计时的好的方法论</strong></p>
<ul>
<li>关注端到端的价值交付，技术团队要持续地顺畅交付有效价值给业务</li>
<li>战略上藐视技术，战术上重视技术</li>
<li>设计技术方案时，一些好的 Idea</li>
<li>以空间换时间，牺牲写性能换取读性能</li>
<li>技术方案注重冷热分离的思考</li>
<li>技术方案注重<a href="https://mp.weixin.qq.com/s/cj67ldIIIkWpdZS92evfiA">推模型、拉模型、推拉结合</a>的思考</li>
<li>故障处理时<code>只换不修</code>的思维, 直接给用户换一个新系统</li>
</ul>
<h1 id="_8">常用的中间件技术总结</h1>
<p><strong>以下是架构师常用到的中间件技术</strong>
包括如下:</p>
<ul>
<li>LB 技术</li>
<li>缓存技术</li>
<li>线程池技术</li>
<li>MQ 技术</li>
<li>数据库技术</li>
<li>服务注册和发现技术</li>
<li>微服务和服务网格技术</li>
<li>客户端网络质量改善技术</li>
<li>客户端稳定性提升技术</li>
<li>客户端埋点最佳实践</li>
</ul>
<h2 id="lb">LB 技术</h2>
<ul>
<li>LB 技术属于常用的一项中间件技术，经常用来做产品的流量入口或者内部服务之间互相调用的中间件. 注意区分 4 层反向代理，还是 7 层反向代理.</li>
<li>LB 的负载均衡策略，可以参考前面总结的"Nginx 的均衡策略", 其他的负载均衡器具备的能力都非常相似.</li>
</ul>
<h2 id="_9">缓存技术</h2>
<h3 id="_10">工程上，缓存一般有几种使用方式？</h3>
<h4 id="1">（1）进程内缓存；</h4>
<h4 id="2">（2）进程外缓存，也就是缓存服务；</h4>
<h3 id="_11">如果有多个服务使用进程内缓存，如何保证一致性？</h3>
<p>常见的有三种方法：</p>
<ol>
<li>服务节点同步通知；</li>
<li>MQ 异步通知；</li>
<li>牺牲少量一致性，定期后端更新；</li>
</ol>
<h3 id="redis">绝大部分情况，还是应该使用缓存服务(例如 Redis). 缓存服务的使用，有什么注意点？</h3>
<p>以下几点，应该要注意：</p>
<ol>
<li>服务与服务之间不要通过缓存传递数据；</li>
<li>如果缓存挂掉，可能导致雪崩，此时要做高可用缓存，或者水平切分；</li>
<li>调用方不宜再单独使用缓存存储服务底层的数据，容易出现数据不一致，以及反向依赖；</li>
<li>不同服务，缓存实例要做垂直拆分，不宜共用缓存；</li>
</ol>
<h3 id="_12">缓存服务的最佳实践</h3>
<h4 id="_13">读缓存最佳实践</h4>
<ol>
<li>先读缓存，命中则返回；未命中则读数据库，然后设置缓存。</li>
</ol>
<h4 id="_14">写缓存最佳实践</h4>
<ol>
<li>淘汰缓存，而不是修改缓存；</li>
<li>先操作数据库，再操作缓存；</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/tckgt4Mvc-BqGHE99WlhGw">高并发下先操作数据库, 还是先操作缓存?</a></p>
<h3 id="_15">缓存的本质是什么</h3>
<ul>
<li>缓存的本质是“冗余了数据库中的数据”。 可能存在什么问题？缓存与数据库数据不一致。</li>
<li>出现不一致时，优化思路是什么？及时把缓存中的脏数据淘汰掉。</li>
</ul>
<h3 id="redis_1">什么时候选择优先使用 Redis？</h3>
<h4 id="1_1">（1）需要支持复杂数据结构；</h4>
<h4 id="2_1">（2）需要支持持久化；</h4>
<h4 id="3">（3）需要天然高可用；</h4>
<h4 id="4value">（4）value 存储内容比较大；</h4>
<h2 id="_16">线程池技术</h2>
<ul>
<li>这里区分<code>连接池</code>和<code>线程池</code>, 其实本质上都是保存<code>worker</code>的池子</li>
</ul>
<h3 id="_17">连接池</h3>
<p>连接池的核心是什么？两个核心数据结构：连接数组，锁数据；三个核心接口：初始化，拿出连接，放回连接；</p>
<h3 id="_18">线程池</h3>
<h4 id="worker"><a href="https://mp.weixin.qq.com/s/OKTW_mZnNJcRBrIFHONR3g">线程池技术</a>解决的问题是： 保持一定量的 worker 线程，把提交任务和执行任务进行解耦.</h4>
<ul>
<li>当任务到达时，任务可以不需要等到线程创建就能立即执行.</li>
</ul>
<h4 id="7">线程池有 7 个核心参数</h4>
<p><img alt="png" src="../../img/DE25F5F4-4689-4DFC-8D00-1D012765CB84.png" /></p>
<ul>
<li>
<p>这些参数分别是</p>
</li>
<li>
<p><code>int corePoolSize</code>：核心线程数</p>
</li>
<li><code>int maximumPoolSize</code>：最大线程数</li>
<li><code>long keepAliveTime</code>：非核心线程的空闲时间</li>
<li><code>TimeUnit unit</code>：空闲时间的单位</li>
<li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>：任务队列（线程安全的阻塞队列）</li>
<li><code>ThreadFactory threadFactory</code>：线程工厂</li>
<li>
<p><code>RejectedExecutionHandler handler</code>：拒绝策略</p>
</li>
<li>
<p><code>corePoolSize</code>: 一开始任务数少的时候， 线程数量不会一下子全开好，而是每当有一个新任务进来，同时没有空闲线程时，就会新开一个线程, 如何创建线程呢，由<code>theadFactory</code>方法指定。直到达到<code>corePoolSize</code> 这个数量</p>
</li>
<li>
<p>当达到<code>corePoolSize</code>时，如果还有任务不断被提交进来，同时没有空闲线程去做这些任务，那么会被加入一个队列， <code>workQueue</code></p>
</li>
<li>
<p>直到有那么一个时刻，<code>workQueue</code>满了，（主要是秒杀类的高 QPS 业务场景）那么线程池又会继续加线程数量，直到加满<code>maximumPoolSize</code></p>
</li>
<li>
<p>如果加满<code>maximumPoolSize</code>还不够，那么新来的任务会被拒绝，拒绝的处理者就是那个<code>handler</code>定义的方法.</p>
</li>
<li>
<p>如果加满（或者大于 <code>corePoolSize</code> 但是小于 <code>maximumPoolSize</code> ）<code>maximumPoolSize</code>足够处理新任务, 那么一段时间后，会有空闲的线程出来。 这些线程就称为 <code>非核心线程</code>， <code>非核心线程</code>空闲一段时间后 ，（这段时间由<code>keepAliveTime * unit</code>决定），就会被销毁，减少系统资源消耗.</p>
</li>
</ul>
<h4 id="_19">任务提交到线程池的整体流程</h4>
<p><img alt="png" src="../../img/WechatIMG165.png" /></p>
<h2 id="mq">MQ 技术</h2>
<h3 id="3_1">3 个核心模型</h3>
<ul>
<li>消息(Message)</li>
<li>发布者: (Producer)</li>
<li>消费者(处理者): Consumer(worker)</li>
</ul>
<h3 id="3_2">3 个核心应用场景</h3>
<ul>
<li>解耦</li>
<li>
<ul>
<li>上下游服务进行隔离，整体架构更加清晰、整洁.</li>
</ul>
</li>
<li>削峰</li>
<li>
<ul>
<li>对于短时间内极端流量，对后端服务可以启到保护作用.</li>
</ul>
</li>
<li>异步</li>
<li>
<ul>
<li>针对长时间的任务, 前端可以快速给用户反馈，后端可以慢慢处理.</li>
</ul>
</li>
</ul>
<h2 id="_20">数据库技术</h2>
<p>这里主要探讨数据库设计上一些思考点</p>
<h3 id="_21">工程上，数据库要设计一些什么？</h3>
<ol>
<li>根据“业务模式”设计表结构；</li>
<li>根据“访问模式”设计索引结构；</li>
</ol>
<h3 id="_22">架构上，数据库还必须考虑什么？</h3>
<ol>
<li>读性能提升；</li>
<li>高可用；</li>
<li>一致性保障；</li>
<li>扩展性；</li>
<li>垂直拆分；</li>
</ol>
<h3 id="_23">提升系统读取速度，有哪几种常见方法？</h3>
<ol>
<li>建立索引；</li>
<li>增加从库；</li>
<li>增加缓存</li>
</ol>
<h3 id="_24">如何保证数据库的高可用？</h3>
<ul>
<li>核心思想是：冗余+故障自动转移.</li>
<li>写库高可用，冗余写库；</li>
<li>读库高可用，冗余读库；</li>
</ul>
<h3 id="_25">主从延时，有什么优化方案？</h3>
<ol>
<li>业务容忍；</li>
<li>强制读主；</li>
<li>在从库有可能读到旧数据时，选择性读主</li>
</ol>
<h2 id="service-discovery">服务发现（Service Discovery）中间件</h2>
<p>服务发现要解决的是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听 udp 或 tcp 端口，并且通过名字就可以查找和连接。</p>
<h3 id="3_3">解决服务发现的 3 大支柱</h3>
<p>要解决服务发现的问题，需要有下面三大支柱，缺一不可:</p>
<ol>
<li><strong>一个强一致性、高可用的服务存储目录.</strong>
   基于 Raft 算法的 etcd 天生就是这样一个强一致性高可用的服务存储目录。 一致性 k/v 存储.</li>
<li><strong>一种注册服务和监控服务健康状态的机制。</strong> 用户可以在 etcd 中注册服务，并且对注册的服务设置 key TTL，然后定时保持服务的心跳以达到监控健康状态的效果。</li>
<li><strong>一种查找和连接服务的机制。</strong> 通过在 etcd 指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个 Proxy 模式的 etcd，这样就可以确保能访问 etcd 集群的服务都能互相连接。
   <img alt="png" src="../../img/20180905111736.jpeg" /></li>
</ol>
<h3 id="_26">关于自动服务发现</h3>
<ul>
<li>是不需要修改配置，就发现了服务，调用了服务</li>
<li>有一个地方动态的读取配置，从而能自动去调用服务。</li>
<li>
<ul>
<li>举个例子, 比如 Prometheus 进程每 5 分钟周期性读取一下配置文件(<code>/etc/prometheus/prometheus-file-sd.yml</code>), 因此相应的监控 Job 修改之后无需重启 Prometheus 进程自动会被发现.</li>
</ul>
</li>
</ul>
<h4 id="_27">服务中心</h4>
<p>在服务中心中，分为两种：</p>
<ul>
<li>一种是名称总线系统，也就是 A 系统需要调用某个服务的时候，只要请求服务中心即可，服务中心会自己去调用远程的服务然后得到响应，最后由服务中心响应给 A 系统。（ESB 企业服务总线）</li>
</ul>
<p><img alt="png" src="../../img/WechatIMG416.png" /></p>
<ul>
<li>一种是名称服务系统，也就是 A 系统需要调用某个服务的时候，去服务中心获取到远程的服务 ip+port，然后 A 系统自己发送请求获得响应（和 DNS 类似，只是为了解析出 IP 和端口)</li>
</ul>
<p><img alt="png" src="../../img/WechatIMG417.png" /></p>
<h4 id="consul">Consul 架构图</h4>
<p>Consul 的作用主要是管理这些集群服务的配置，整体流程是这样子的：服务（进程）启动的时候把服务名和自己的 IP、端口通过 HTTP 告诉我，我将这些信息记到自己的内存表格中，客户端调用时带上要查询的服务名通过 HTTP 发送给我，我再自己的内存表中找到叫这服务名的所有配置发送给客户端。
平时我还要做一些服务健康检查的事儿，在上面服务启动的时候，服务还要给我配置一个检查接口和检查频率等一些参数，我会按这些参数每隔一段时间，比如 10 秒钟去请求一下这个接口，如果不通，我就隔 5 秒再重试下，如果重试 3 次还不通，我就认定这个服务挂掉了，就从内存表格中删掉这个服务配置，不然客户端要请求到这个不通服务，我就罪过了。</p>
<p><img alt="png" src="../../img/WechatIMG418.jpeg" /></p>
<p>Consul 更像是一个 full stack 的解决方案，它不仅提供了一致性 k/v 存储，还封装了服务发现，健康检查，内置了 DNS server 等等.</p>
<h2 id="service-mesh">微服务架构和服务网格（Service Mesh）</h2>
<h3 id="_28">常见的服务端架构</h3>
<p><img alt="png" src="../../img/suoyoujiqunjiagou.jpg" /></p>
<h3 id="_29">微服务架构要解决什么问题?</h3>
<ul>
<li>
<p>用户流量进入服务端之后, 服务端(指上图中的<code>Web服务</code>和<code>Worker集群</code>)多种<code>应用</code>可以和<code>操作系统的进程</code>形成<code>多对多的模式</code>, 每种<code>应用</code>有如下特性</p>
</li>
<li>
<p>顺畅、低成本的互相调用别的<code>应用</code></p>
</li>
<li>高可用</li>
<li>无限性能扩展(自动化扩缩容)</li>
<li>
<p>负载均衡</p>
</li>
<li>
<p>微服务部署的最佳实践是什么? Kubernetes 集群</p>
</li>
</ul>
<p><img alt="png" src="../../img/WechatIMG178.jpeg" /></p>
<h3 id="service-mesh_1">Service Mesh 的由来</h3>
<h4 id="_30">负载均衡、数据收集、服务发现、调用链跟踪。这些非业务的功能，一般是谁实现的呢？</h4>
<ol>
<li>互联网公司一般会有一个“架构部”，研发框架、组件、工具与技术平台；</li>
<li>业务研发部门直接使用相关框架、组件、工具与技术平台，享受各种“黑科技”带来的便利；</li>
<li>对于上述“黑科技”的使用与推广，存在什么问题？框架、组件、工具与技术平台的使用与推广，往往会遇到以下一些问题：</li>
<li>业务研发团队，需要花大量时间去学习、使用基础框架与各类工具；</li>
<li>架构部，对于“黑科技”不同语言客户端的支持，往往要开发 C-client，Python-client，go-client，Java-client 多语言版本；</li>
<li>架构部，“黑科技” client 要维护 m 个版本， server 要维护 n 个版本，兼容性要测试 m*n 个版本；</li>
<li>每次“黑科技”的升级，都需要推动上下游进行升级，这个周期往往是以季度、半年、又甚至更久，整体效率极低；</li>
</ol>
<p>解决思路是: <code>解耦，将业务服务拆分成两个进程</code>：</p>
<p><img alt="png" src="../../img/WechatIMG168.png" /></p>
<ol>
<li>一个进程实现业务逻辑（不管是调用方，还是服务提供方），<code>biz</code>，即上图白色方块；</li>
<li>一个进程实现底层技术体系，<code>proxy</code>，即上图蓝色方块；(负载均衡、监控告警、服务发现与治理、调用链…等诸多基础设施，都放到这一层实现。)</li>
</ol>
<p>他们之间有这样一些特点：
<img alt="png" src="../../img/WechatIMG168.png" /></p>
<ol>
<li>biz 和 proxy 共同诞生，共同消亡，互为本地部署，即上图虚线方框；</li>
<li>biz 和 proxy 之间，为本地通讯，即上图黑色箭头； 3.所有 biz 之间的通讯，都通过 proxy 之间完成，proxy 之间才存在远端连接，即上图红色箭头；</li>
</ol>
<p>这样就实现了<code>业务的归业务，技术的归技术</code>，实现了充分解耦，如果所有节点都实现了解耦，整个架构会演变为：
<img alt="png" src="../../img/WechatIMG169.png" /></p>
<ul>
<li>绿色为<code>biz</code>；</li>
<li>蓝色为<code>proxy</code>；
  整个服务集群变成了网格状，这就是<code>Service Mesh服务网格</code>的由来。</li>
</ul>
<h4 id="service-mesh_2">Service Mesh 的行业开源最佳实践是什么？</h4>
<p><code>Istio</code></p>
<h4 id="istio">Istio 的架构核心是什么？</h4>
<p>Istio 架构分为两层：</p>
<ol>
<li>数据平面(data plane)；</li>
<li>控制平面(control plane)；
   <img alt="png" src="../../img/WechatIMG170.png" /></li>
</ol>
<h4 id="istio_1">Istio 的优势讲解</h4>
<p><a href="https://mp.weixin.qq.com/s/CALHF1UBpiKtNNS-NFHVnA?locale=zh-CN">参考</a></p>
<h5 id="1-kubernetes-service-clusterip">1. 一开始, Kubernetes 集群内部，通过 Service 的 ClusterIP 进行互相调用的情况</h5>
<p><img alt="png" src="../../img/WechatIMG177.jpeg" />
上图的 <code>Kubernetes</code> 集群中一共有两个节点和 4 个 <code>Pod</code>，每个 <code>Pod</code> 都有一个容器。服务 <code>service-nginx</code> 指向 <code>nginx pods</code>，服务 <code>service-python</code> 指向 <code>python pods</code>。红线显示了从 <code>pod1-nginx</code> 中的 <code>nginx</code> 容器向 <code>service-python</code> 服务发出的请求，该服务将请求重定向到 <code>pod2-python</code>。</p>
<p>通过服务的<code>ClusterIP</code> 向后端<code>Pod</code>进行简单的随机或轮询转发请求，<code>Kubernetes</code> 中的 <code>Services</code> 并不存在于特定的节点上，而是存在于整个集群中。我们可以在下图 中看到更多细节:</p>
<p><img alt="png" src="../../img/WechatIMG173.jpeg" /></p>
<p>上图要更详细点，Kubernetes 中的服务是由运行在每个节点上的 kube-proxy 组件实现的，该组件创建 iptables 规则，并将请求重定向到 Pod。因此，服务就是 iptables 规则。(还有其他不使用 iptables 的代理模式，但过程是相同的。)</p>
<h4 id="2-istio-control-plane-data-plane">2. 有了 Istio 之后, Control Plane 和 Data Plane 之间通讯的示意图</h4>
<p><img alt="png" src="../../img/64020210725.png" />
<code>Istio</code> 最常见的代理是 <code>Envoy</code>，当然也可以使用其他代理（如 <code>Nginx</code>），所以我们将代理称为<code>istio-proxy</code>。</p>
<p>我们可以看到不再显示 <code>kube-proxy</code> 组件，这样做是为了保持图像的整洁，这些组件仍然存在，但是拥有 <code>istio-proxy</code> 的 <code>Pods</code> 将不再使用 <code>kube-proxy</code> 组件了。
每当配置或服务发生变化时，<code>Istio 控制平面</code>就会对所有 <code>istio-proxy sidecars</code> 进行处理，类似于图 2 中 Kubernetes API 处理所有 kube-proxy 组件的方式。<code>Istio 控制平面</code>使用现有的 Kubernetes 服务来接收每个服务点所指向的所有 pods ，通过使用 pod IP 地址，Istio 实现了自己的路由。</p>
<h4 id="3-istio-istio-proxy-sidecars">3 在 Istio 控制平面对所有 istio-proxy sidecars 处理之后，它看起来是这样的</h4>
<p><img alt="png" src="../../img/WechatIMG174.jpeg" /></p>
<p>在图 4 中，我们看到 Istio 控制平面如何将当前配置应用到集群中的所有 istio-proxy 容器，Istio 将把 Kubernetes 服务声明转换成它自己的路由声明。</p>
<h4 id="4-istio">4 让我们看看如何使用 Istio 发出请求:</h4>
<p><img alt="png" src="../../img/WechatIMG175.jpeg" />
在上图中，所有的 <code>istio-proxy</code> 容器已经被 <code>Istio 控制平面</code>所管控，并包含所有必要的路由信息，如图 3/4 所示，来自 <code>pod1-nginx</code> 的 <code>nginx 容器</code>向 <code>service-python</code> 发出请求。</p>
<p>请求被 <code>pod1-nginx</code> 的 <code>istio-proxy</code> 容器拦截，并被重定向到一个 <code>python pod</code> 的 <code>istio-proxy</code> 容器，该容器随后将请求重定向到 <code>python</code> 容器。</p>
<h5 id="istio_2">Istio 的优势总结</h5>
<p>现在所有流量都通过每个 Pod 中的 <code>istio-proxy</code> 容器进行路由，每当 <code>istio-proxy</code> 接收并重定向一个请求时，它还会将有关该请求的信息提交给 <code>Istio 控制平面</code>。因此 <code>Istio 控制平面</code>可以准确地知道该请求来自哪个 Pod、存在哪些 HTTP 头、从一个<code>istio-proxy</code> 到另一个 <code>istio-proxy</code> 的请求需要多长时间等等。在具有彼此通信的服务的集群中，这可以提高可观察性并更好地控制所有流量</p>
<ul>
<li>
<p><code>先进的路由</code>，<code>Kubernetes</code> 内部 <code>Services</code> 只能对 <code>Pods</code> 执行轮询或随机分发请求，使用 <code>Istio</code> 可以实现更复杂的方式。比如，如果发生错误，根据请求头进行重定向，或者重定向到最少使用的服务。</p>
</li>
<li>
<p><code>部署</code>，它允许将一定比例的流量路由到特定的服务版本，因此允许绿色/蓝色和金丝雀部署。</p>
</li>
<li>
<p><code>加密</code>，可以对 <code>Pods</code> 之间从 <code>istio-proxy</code> 到 <code>istio-proxy</code> 的集群内部通信进行加密。</p>
</li>
<li>
<p><code>监控/图形</code>，<code>Istio</code> 可以连接到 <code>Prometheus</code> 等监控工具，也可以与 <code>Kiali</code> 一起展示所有的服务和他们的流量。
  <img alt="png" src="../../img/WechatIMG176.jpeg" /></p>
</li>
<li>
<p><code>追踪</code>，因为 <code>Istio 控制平面</code>拥有大量关于请求的数据，所以可以使用 Jaeger 等工具跟踪和检查这些数据。</p>
</li>
</ul>
<h2 id="_31">客户端网络质量改善技术</h2>
<h3 id="_32">本质上都是利用边缘节点(代理节点)以及优化的骨干网络来降低用户访问服务端的延迟，提升用户体验.</h3>
<ul>
<li>代理节点</li>
<li>CDN 的边缘节点</li>
<li>公司自研的代理节点</li>
<li>做好自动主备切换多 CDN 供应商</li>
<li>优化的骨干网络</li>
<li><a href="https://mp.weixin.qq.com/s/qur3Csb3WEWKavFdx9BjBg">利用公有云的骨干网络</a></li>
<li>拉专线</li>
</ul>
<h2 id="_33">客户端稳定性提升</h2>
<blockquote>
<p>以下是不同业务客户端都会需要的一些通用功能</p>
</blockquote>
<ul>
<li>客户端网络探测器, 探测最快到达服务端的路径利器, 客户端选择路径有时候并不是直连服务端最快，而是先连接到加速节点, 再由加速节点代理回到服务端快. 因此不同客户端直接需要实现一个通用的 SDK.</li>
<li>客户端 Dump 系统, 搜集不同客户端奔溃率并上报.</li>
<li>客户端通用下载器, 业务程序无需实现下载逻辑, 直接调用相关 SDK</li>
<li>HTTPDNS SDK, 防劫持</li>
<li>LBS SDK, 客户端获取地理位置、附近的人等</li>
<li>通用问题探测(Detect)和上报相关 SDK, 不同客户端可以直接集成该 SDK, 在用户使用客户端的任意阶段有问题都可以上报</li>
</ul>
<h2 id="_34">客户端埋点最佳实践</h2>
<ul>
<li>待补充</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../rongliangguanli/" class="btn btn-neutral float-left" title="第六篇 容量管理概述"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../cicd/" class="btn btn-neutral float-right" title="第八篇 CICD流程概述">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../rongliangguanli/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../cicd/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
