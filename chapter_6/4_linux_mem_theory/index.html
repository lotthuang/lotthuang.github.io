<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>第四篇 Linux内存管理原理 - Lott's Blog</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u7b2c\u56db\u7bc7 Linux\u5185\u5b58\u7ba1\u7406\u539f\u7406";
    var mkdocs_page_input_path = "chapter_6/4_linux_mem_theory.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Lott's Blog</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">首页</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第一章 常用软件</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../chapter_1/1_make_blog/">第一篇 利用Github Pages和mkdocs搭建个人博客</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_1/2_nginx_loadbalancing_strategy/">第二篇 Nginx的均衡策略</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第二章 运维工作总结</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../chapter_2/yunweijiazhi/">第一篇 运维的价值和目标</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_2/yunweizhiyeguifan/">第二篇 业务SRE的职业规范</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_2/yunweipingtailinian/">第三篇 运维平台建设的理念</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_2/guzhangguanli/">第四篇 故障管理概述</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_2/biangengguanli/">第五篇 变更管理概述</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_2/rongliangguanli/">第六篇 容量管理概述</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_2/jiagoushisiweihetezhi/">第七篇 架构师思维和特质以及中间件技术梳理</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_2/cicd.md">第八篇 CICD流程概述</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第三章 Linux Net子系统</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../chapter_3/1_linux_kernel_net/">第一篇 Linux数据包接收路径梳理和常用调优技能</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_3/2_estab_queue_monitoring/">第二篇 Linux下如何观察完整连接队列的情况</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_3/3_net_ipv4_tcp_syn_retries/">第三篇 理解net.ipv4.tcp_syn_retries设置</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_3/4_linux_kernel_net_v2/">第四篇 Linux网络数据包的揭秘以及常见的调优方式总结</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_3/5_conntrack/">第五篇 conntrack的常见应用</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_3/6_tcp/">第六篇 TCP协议总结</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_3/7_udp/">第七篇 UDP协议总结以及TCP和UDP的区别</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_3/8_io_multiplexing/">第八篇 IO多路复用总结</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第四章 Linux CPU子系统</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../chapter_4/1_process_ulimit/">第一篇 进程Max open files的设置</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_4/2_pid_max/">第二篇 kernel源码中pid的最大值</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_4/3_interrupt_one/">第三篇 硬中断</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_4/5_soft_irq/">第四篇 软中断</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_4/4_process_thread_coroutine/">第五篇 进程、线程、协程</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第五章 Linux IO子系统</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../chapter_5/1_four_object_of_VFS/">第一篇 VFS四大对象inode、dentry、super_block、file数据结构总结</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_5/2_io_stack/">第二篇 Linux IO栈总结</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_5/3_zero_copy/">第三篇 Linux 零拷贝技术总结</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第六章 Linux Mem子系统</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../1_linux_buddy/">第一篇 伙伴系统介绍</a>
                </li>
                <li class="">
                    
    <a class="" href="../../daibuchong/">第二篇 Slab层介绍</a>
                </li>
                <li class="">
                    
    <a class="" href="../../daibuchong/">第三篇 进程虚拟地址空间介绍</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">第四篇 Linux内存管理原理</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#_1">概述</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#_2">虚拟内存的由来</a></li>
        
            <li><a class="toctree-l4" href="#_3">内存分段</a></li>
        
            <li><a class="toctree-l4" href="#_5">分段机制的问题</a></li>
        
            <li><a class="toctree-l4" href="#_7">内存分页</a></li>
        
        </ul>
    

    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第七章 运维小技巧和工具汇总和积累</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../chapter_7/1_sync_file/">第一篇 不同主机之间的文件传输</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_7/2_sre_tools_python/">第二篇 运维生产力工具(python篇)</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_7/3_sre_tools_website/">第三篇 运维生产力工具(网站工具)</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_7/4_sre_tools_shell/">第四篇 运维生产力工具(shell篇)</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_7/5_server_side_evolution/">第五篇 服务端进化过程梳理</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_7/6_elk/">第六篇 elk技术栈</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第八章 职场通用经验</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../chapter_8/1_xuexixinde/">第一篇 个人学习心得总结</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_8/2_bangzhuqitatongxue/">第二篇 如何帮助其他同学提升技术能力</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_8/3_yewuliuchengshuyu/">第三篇 业务流程术语梳理</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_8/4_jishunenglimoxing/">第四篇 技术能力模型总结</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_8/5_chanpingsiwei_1/">第五篇 产品思维总结和梳理</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_8/6_jixiaobaogao/">第六篇 如何写绩效报告</a>
                </li>
                <li class="">
                    
    <a class="" href="../../chapter_8/7_xiangshangguanli/">第七篇 如何向上管理</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第九章 编程经验</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../chapter_9/1_suanfa/">第一篇 算法总结</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">第十章 容器化和Kubernetes</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../chapter_10/1_dockerfile_best_practice/">第一篇 dockerfile最佳实践</a>
                </li>
                <li class="">
                    
    <a class="" href="../../daibuchong/">第二篇 Kubernetes基础概念</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Lott's Blog</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>第六章 Linux Mem子系统 &raquo;</li>
        
      
    
    <li>第四篇 Linux内存管理原理</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="_1">概述</h1>
<ul>
<li>总结Linux内存管理原理. 讲述虚拟内存、分段、分页的进化过程.</li>
<li>计算机启动时, 分页机制必须提交准备好才可以运行真正的<code>start_kernel()</code>函数.</li>
</ul>
<h2 id="_2">虚拟内存的由来</h2>
<p>如果你是电子相关专业的，肯定在大学里捣鼓过单片机。</p>
<p>单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。</p>
<p>另外，<strong>单片机的 CPU 是直接操作内存的「物理地址」</strong>。</p>
<p><img alt="png" src="../../img/WechatIMG286.png" /></p>
<p>在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第二个程序在 2000 的位置写入一个新的值，将会擦掉第一个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。</p>
<blockquote>
<p>操作系统是如何解决这个问题呢？</p>
</blockquote>
<p>这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。</p>
<p>我们可以把进程所使用的地址<code>「隔离」</code>开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。</p>
<p><img alt="png" src="../../img/WechatIMG289.png" /></p>
<p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p>
<p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p>
<p>于是，这里就引出了两种地址的概念：</p>
<ul>
<li>
<p>我们程序所使用的内存地址叫做<strong>虚拟内存地址（Virtual Memory Address）</strong></p>
</li>
<li>
<p>实际存在硬件里面的空间地址叫<strong>物理内存地址（Physical Memory Address）</strong>。</p>
</li>
</ul>
<p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p>
<p><img alt="png" src="../../img/WechatIMG290.jpeg" /></p>
<p>操作系统是如何管理虚拟地址与物理地址之间的关系？</p>
<p>主要有两种方式，分别是<strong>内存分段</strong>和<strong>内存分页</strong>，分段是比较早提出的，我们先来看看内存分段。</p>
<blockquote>
<p>了解分段的原理之前我们需要提前说明一些CPU寄存器.</p>
</blockquote>
<h3 id="cpu">著名的CPU寄存器</h3>
<ul>
<li>cs （代码段寄存器）</li>
<li>ss （栈段寄存器）</li>
<li>ds （数据段寄存器）</li>
<li>gdtr寄存器, 存放 <code>全局描述符GDT（Global Descriptor Table)</code>的地址.<ul>
<li>GDT本身则存放在内存中.</li>
</ul>
</li>
<li>idtr，存放中断向量表的地址. <code>中断向量表IDT(Interrupt  Descriptor Table)</code>  有多行，每一行代表某一个中断号发生之后，要执行的函数.<ul>
<li>IDT本身则存放在内存中</li>
</ul>
</li>
</ul>
<h2 id="_3">内存分段</h2>
<p>程序是由若干个逻辑分段组成的，如可由<code>代码分段</code>、<code>数据分段</code>、<code>栈段</code>、<code>堆段</code>组成。不同的段是有不同的属性的，所以就用<code>分段（Segmentation）</code>的形式把这些段分离出来。</p>
<p>分段机制下的虚拟地址由两部分组成，<code>段选择子</code>和<code>段内偏移量</code>。</p>
<p><img alt="png" src="../../img/WechatIMG287.jpeg" /></p>
<ul>
<li>
<p><code>段选择子</code>就保存在段寄存器里面。段选择子里面最重要的是<code>段号</code>，用作<code>段表</code>的索引。<code>段表</code>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</p>
</li>
<li>
<p>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</p>
</li>
<li>
<p>这里提到的<code>段表</code>, 就是 <code>全局描述符表GDT（Global Descriptor Table)</code>, 它的实际位置存放在内存中, CPU的<code>gdtr寄存器</code>存放了GDT的地址.</p>
</li>
</ul>
<p>在上面了，知道了虚拟地址是通过<code>段表</code>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</p>
<p><img alt="png" src="../../img/WechatIMG294.jpeg" /></p>
<p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。</p>
<h3 id="_4">如何从虚拟地址得到对应的物理地址</h3>
<p><strong>【段选择子+段偏移地址】</strong>中的<code>段选择子</code>可以认为是一个索引，这个索引指向了<code>全局段描述符表</code>中的一项，全局段描述表存储在内存中，它的起始地址存储在全局段描述符寄存器中。</p>
<p>全局段描述符表有很多个<code>段描述符</code>，每个<code>段描述符</code>占用8个字节，这个<code>段描述符</code>里面就包括了<code>段基址</code>，另外还有一些安全性相关的描述信息例如段的<code>可读，可写，可执行，段的大小</code>等。</p>
<p>段选择子存储在了段寄存器中，总共16位,其中高13位就是全局段描述表的索引。</p>
<p>段选择符的结构： <img alt="png" src="../../img/3B7FB0E9-9828-44A2-9EA4-2BC635D136B0.jpg" /></p>
<p>当CPU开始执行代码段的第一条指令时,会将代码段的选择子放入到CS段寄存器中,然后CPU从段寄存器中的获取段选择子，然后截取选择子的高13位获取索引，然后根据全局描述符表寄存器的地址找到全局描述符表的起始地址，根据起始地址+索引*8找到段描述符,然后根据段描述符获取段的基址，段的基址加上ip寄存器中的偏移地址就是指令的物理地址，如下图所示1~6步骤所示</p>
<p><img alt="png" src="../../img/WechatIMG291.jpeg" /></p>
<p>当CPU执行到0x00600000处的代码指令时，该指令为MOV AX,[0]，该指令的意思是把地址0处的数据存储到AX寄存器，这个0就是数据段的偏移地址，此时CPU会将数据段的选择子加入到DS段寄存器中,然后CPU获取段选择的高13位获取索引，然后根据全局描述符表寄存器的地址找到全局描述符表的起始地址，根据起始地址+索引*8找到段描述符,然后根据段描述符获取段的基址，段的基址加上数据段的偏移地址就是数据的物理地址，如下图1~6步骤所示</p>
<p><img alt="png" src="../../img/WechatIMG292.jpeg" /></p>
<h2 id="_5">分段机制的问题</h2>
<p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：</p>
<ul>
<li>
<p>第一个就是内存碎片的问题。</p>
</li>
<li>
<p>第二个就是内存交换的效率低的问题。</p>
</li>
</ul>
<blockquote>
<p>接下来，说说为什么会有这两个问题。</p>
</blockquote>
<p>我们先来看看，分段为什么会产生内存碎片的问题？</p>
<h3 id="1g">我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</h3>
<ul>
<li>
<p>游戏占用了 512MB 内存</p>
</li>
<li>
<p>浏览器占用了 128MB 内存</p>
</li>
<li>
<p>音乐占用了 256 MB 内存。</p>
</li>
</ul>
<p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。</p>
<p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p>
<p><img alt="png" src="../../img/WechatIMG295.jpeg" /></p>
<p>这里的内存碎片的问题共有两处地方：</p>
<ul>
<li>
<p>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；</p>
</li>
<li>
<p>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；</p>
</li>
</ul>
<p>针对上面两种内存碎片的问题，解决的方式会有所不同。</p>
<p>解决外部内存碎片的问题就是<strong>内存交换</strong>。</p>
<p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p>
<h3 id="_6">再来看看，分段为什么会导致内存交换效率低的问题？</h3>
<p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 <code>Swap 内存区域</code>，这个过程会产生性能瓶颈。</p>
<p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p>
<p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿</strong>。</p>
<p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。</p>
<h2 id="_7">内存分页</h2>
<p>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。</p>
<p>要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是<code>内存分页（Paging）</code>。</p>
<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。</strong>这样一个连续并且尺寸固定的内存空间，我们叫<code>页（Page）</code>。在 Linux 下，每一页的大小为 <code>4KB</code>。</p>
<p><code>虚拟地址</code>与<code>物理地址</code>之间通过<code>页表</code>来映射，如下图：</p>
<p><img alt="png" src="../../img/WechatIMG296.jpeg" /></p>
<p>页表实际上存储在 CPU 的<strong>内存管理单元 （MMU）</strong> 中，于是 CPU 就可以直接通过 <code>MMU</code>，找出要实际要访问的物理内存地址。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<code>缺页异常</code>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<blockquote>
<p>分页是怎么解决分段的内存碎片、内存交换效率低的问题？</p>
</blockquote>
<p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而<code>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存</code>。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<code>换出（Swap Out）</code>。一旦需要的时候，再加载进来，称为<code>换入（Swap In）</code>。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<code>内存交换的效率就相对比较高</code>。</p>
<p><img alt="png" src="../../img/WechatIMG334.jpeg" /></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<code>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去</code>。</p>
<blockquote>
<p>分页机制下，虚拟地址和物理地址是如何映射的？</p>
</blockquote>
<p>在分页机制下，虚拟地址分为两部分，<code>页号</code>和<code>页内偏移</code>。<code>页号</code>作为<code>页表</code>的索引，<code>页表</code>包含物理页每页所在<code>物理内存的基地址</code>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</p>
<p><img alt="png" src="../../img/WechatIMG335.jpeg" /></p>
<h4 id="linux">Linux下页表</h4>
<ul>
<li>Linux 中使用<code>struct mm_struct</code>表示进程的虚拟地址空间</li>
<li><code>mm_struct</code>中有一个<code>pgd</code>域, 指向 <code>struct pgd_t</code>表示进程的页表</li>
</ul>
<p><img alt="png" src="../../img/F1382197-8D08-4D3C-82F0-F2F2BDA3BE9B.png" /></p>
<p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>
<p>把虚拟内存地址，切分成页号和偏移量；</p>
</li>
<li>
<p>根据页号，从页表里面，查询对应的物理页号；</p>
</li>
<li>
<p>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</p>
</li>
</ul>
<p>下面举个例子，虚拟内存中的页通过页表映射为了物理内存中的页，如下图：</p>
<p><img alt="png" src="../../img/WechatIMG336.jpeg" /></p>
<h3 id="_8">单极页表的问题和多级页表的引入</h3>
<p><a href="https://mp.weixin.qq.com/s/HJB_ATQFNqG82YBCRr97CA">参考1</a>
<a href="https://mp.weixin.qq.com/s/80LjQ9o8JIZu0PxY7PgKAw?locale=zh-CN">参考2</a></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../chapter_7/1_sync_file/" class="btn btn-neutral float-right" title="第一篇 不同主机之间的文件传输">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../../daibuchong/" class="btn btn-neutral" title="第三篇 进程虚拟地址空间介绍"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../../daibuchong/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../chapter_7/1_sync_file/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
