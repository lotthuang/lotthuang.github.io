<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>第四篇 Linux内存管理基础篇 - Lott's Blog</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u7b2c\u56db\u7bc7 Linux\u5185\u5b58\u7ba1\u7406\u57fa\u7840\u7bc7";
        var mkdocs_page_input_path = "chapter_6/4_linux_mem_theory.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Lott's Blog
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">第一章 各种杂项基础</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/1_make_blog/">第一篇 利用Github Pages和mkdocs搭建个人博客</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/2_nginx_loadbalancing_strategy/">第二篇 Nginx的均衡策略</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/3_linux_kernel_basic/">第三篇 Linux内核基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/4_linux_kernel_mm_basic/">第四篇 Linux内核空间内存概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/5_how_kernel_call_bios/">第五篇 Linux内核调用BIOS案例</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/9_linux_arch_overall_introduction/">第九篇 Linux架构整体介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/10_virtual_machine_on_mac_m1_chip/">第十篇 Mac M1芯片电脑利用Qemu安装Debian虚拟机</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/11_nftables/">第十一篇 Debian 11以及往后版本nftables防火墙配置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/12_ansible_basic_use/">第十二篇 Ansible简单使用笔记</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/13_tty_terminal_console/">第十三篇 终端(Terminal)、TTY、PTY和控制台(Console)区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/14_qemu_use/">第十四篇 QEMU模拟各类开发板</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/15_bosun/">第十五篇 Bosun使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/16_assembler/">第十六篇 汇编语言使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/17_makefile/">第十七篇 Makefile使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/19_network_ratelimit/">第十九篇 Linux网络限速</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/20_mac_os_skills/">第二十篇 MacOS使用技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/21_debian_skills/">第二十一篇 Debian使用技巧</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第二章 运维工作总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweijiazhi/">第一篇 运维的价值和目标</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweizhiyeguifan/">第二篇 业务SRE的职业规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweipingtailinian/">第三篇 运维平台建设的理念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/guzhangguanli/">第四篇 故障管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/biangengguanli/">第五篇 变更管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/rongliangguanli/">第六篇 容量管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/jiagoushisiweihetezhi/">第七篇 架构师思维和特质以及中间件技术梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/cicd/">第八篇 CICD流程概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/9_changkanchangxin/">第九篇 常看常新</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/12_monitor_and_alert/">第十二篇 监控报警最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/13_classic_thinkings/">第十三篇 经典思维</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/14_performance_optimization_topic/">第十四篇 性能优化专题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第三章 Linux Net子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/1_linux_kernel_net/">第一篇 Linux数据包接收路径梳理和常用调优技能</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/2_estab_queue_monitoring/">第二篇 Linux下如何观察完整连接队列的情况</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/3_net_ipv4_tcp_syn_retries/">第三篇 理解net.ipv4.tcp_syn_retries设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/4_linux_kernel_net_v2/">第四篇 Linux网络数据包的揭秘以及常见的调优方式总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/5_conntrack/">第五篇 conntrack的常见应用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/6_tcp/">第六篇 TCP协议总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/7_udp/">第七篇 UDP协议总结以及TCP和UDP的区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/8_io_multiplexing/">第八篇 IO多路复用总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/10_linux_net/">第十篇 Linux Net子系统总结、收发包流程再次梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/11_igb/">第十一篇 igb网卡驱动梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/12_rss_rps_rfs_xps/">第十二篇 Linux网卡rss和rps和rfs和xps</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/13_linghunkaowen/">第十三篇 Linux网络子系统灵魂拷问</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第四章 Linux CPU子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/1_process_ulimit/">第一篇 进程Max open files的设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/2_pid_max/">第二篇 kernel源码中pid的最大值</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/3_interrupt_one/">第三篇 硬中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/5_soft_irq/">第四篇 软中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/4_process_thread_coroutine/">第五篇 进程、线程、协程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/6_cpu_famous_register/">第六篇 CPU中的著名寄存器梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/7_linux_signal/">第七篇 Linux信号机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/8_linux_scheduler/">第八篇 Linux进程调度</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/10_linux_context_switch/">第十篇 低视角看context switch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/11_linux_cpu_usage/">第十一篇 CPU利用率统计</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/12_linux_preemption/">第十二篇 内核抢占基础篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/13_interrupt_handler_examples/">第十三篇 中断处理程序的例子</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/14_linux_kernel_tracing/">第十四篇 理解内核追踪机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/15_task_struct/">第十五篇 task_struct结构体总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/16_init_call/">第十六篇 Linux各类initcall总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/17_coredump/">第十七篇 Linux coredump总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第五章 Linux IO子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/1_four_object_of_VFS/">第一篇 VFS四大对象inode、dentry、super_block、file数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/2_io_stack/">第二篇 Linux IO栈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/3_zero_copy/">第三篇 Linux 零拷贝技术总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/4_io_scheduler_layer/">第四篇 Block IO Layer(块IO层)总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/6_fss/">第六篇 各类文件系统梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/7_three_object_of_block_device/">第七篇 块设备三大对象block_device、gendisk、hd_struct数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/8_kobjet_kset_ktype/">第八篇 Linux设备模型的基石:kset/kobject/ktype</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/9_io_uring/">第八篇 io_uring研究和总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第六章 Linux Mem子系统</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../1_linux_buddy/">第一篇 伙伴系统介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../2_slab/">第二篇 Slab层介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../3_virtual_memory/">第三篇 进程虚拟地址空间介绍</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">第四篇 Linux内存管理基础篇</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">虚拟内存的由来</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#cpu">著名的 CPU 寄存器</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">内存分段</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_4">如何从虚拟地址得到对应的物理地址</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">分段机制的问题</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1g">我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">再来看看，分段为什么会导致内存交换效率低的问题？</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_7">内存分页</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#linux">Linux 下页表</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">单极页表的问题和多级页表的引入</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#linux_1">Linux 下段页式内存管理</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1">1 什么是段页式内存管理</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-linux">2 Linux 下的段页式内存管理</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#21-linux">2.1 Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#linux_2">Linux 下内存子系统的优化技能</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-ksm">1 KSM 和 透明大页的区别</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-linux_1">2 Linux 内存子系统所有优化点罗列</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../6_alloc_mem_apis/">第六篇 Linux内核内存分配API函数分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../7_physical_memory/">第七篇 关于物理内存管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../8_linux_mm_update/">第八篇 Linux内存管理升级篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../9_page_cache_and_buffer_cache/">第九篇 PageCache和BufferCache演进过程</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第七章 运维小技巧和工具汇总和积累</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/1_sync_file/">第一篇 不同主机之间的文件传输</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/2_sre_tools_python/">第二篇 运维生产力工具(python篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/3_sre_tools_website/">第三篇 运维生产力工具(网站工具)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/4_sre_tools_shell/">第四篇 运维生产力工具(shell篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/5_server_side_evolution/">第五篇 服务端进化过程梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/7_charset/">第七篇 字符集和编码</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/8_locale/">第八篇 locale设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/9_http_protocol/">第九篇 http协议</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/10_http_cookie_session_token/">第十篇 cookie和session和token总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第八章 职场通用经验</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/1_xuexixinde/">第一篇 学习心得和工作箴言</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/2_bangzhuqitatongxue/">第二篇 工作能力评价体系</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/3_yewuliuchengshuyu/">第三篇 项目管理总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/4_jishunenglimoxing/">第四篇 技术能力模型总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/5_chanpingsiwei_1/">第五篇 产品思维总结和梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/6_jixiaobaogao/">第六篇 如何写绩效报告</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/7_xiangshangguanli/">第七篇 如何向上管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/9_speaking_skills/">第九篇 沟通能力和演讲技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/10_jixiaofangtan/">第十篇 绩效访谈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/11_classic_technical_thinking/">第十一篇 经典技术思维汇总</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第九章 编程经验和各类开源软件</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/1_suanfa/">第一篇 算法总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/2_data_structure/">第二篇 数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/3_c_lang/">第三篇 c语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/4_symbol_table/">第四篇 符号表总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/5_golang/">第五篇 go语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/6_linux_kernel_patch/">第六篇 手把手教你向Linux Kernel提交Patch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/7_python/">第七篇 python语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/8_rsyslog/">第八篇 rsyslog</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/9_falcon/">第九篇 falcon和夜莺</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/10_json_schema/">第十篇 JSON-Schema使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/11_prometheus/">第十一篇 Prometheus使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/12_grafana/">第十二篇 Grafana使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/13_mysql/">第十三篇 MySQL使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/14_mongodb/">第十四篇 MongoDB使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/15_supervisor/">第十五篇 Supervisor使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/16_redis/">第十六篇 Redis使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/17_mongodb_2/">第十七篇 MongoDB基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/18_elk_2/">第十八篇 ELK基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/19_gitlab_ce/">第十九篇 Gitlab-CE维护</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/20_minio/">第二十篇 MinIO维护</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/21_elk_1/">第二十一篇 ELK维护</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十章 容器化和Kubernetes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/1_dockerfile_best_practice/">第一篇 dockerfile最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/2_benefits_of_containerization/">第二篇 容器化好处</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/3_docker_basic_concepts/">第三篇 容器化基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/4_kubernetes_basic_concepts/">第四篇 Kubernetes基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/6_production_kubernetes_best_practice/">第六篇 生产环境Kubernetes部署最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/7_production_kerbernetes_yaml/">第七篇 生产环境Kubernetes YAML模版</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/8_caclio/">第八篇 Kubernetes网络插件之Caclio</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/9_cloudnative_monitor/">第九篇 云原生监控</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/10_event/">第十篇 彻底搞懂Kubernetes Event</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/11_best_practices/">第十一篇 Kubernetes最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/12_cloud_network/">第十二篇 云网络</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/13_containerd/">第十三篇 Containerd</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十一章 SRE稳定性建设从理论到实践</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/1_theory/">第一篇 稳定性概论</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/10_high_avaliable/">第二篇 高可用原则总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/2_slo_process/">第三篇 SLO实施流程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/3_stress/">第四篇 压测经验总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/11_stability/">第五篇 稳定性理论总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十二章 商业化知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_12/1_shifouzhide/">第一篇 如何判断一件事情值不值得做</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十三章 芯片知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_13/1_about_riscv/">第一篇 RISC-V 简介</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十四章 Linux驱动方向总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/1_demo_of_led_driver/">第一篇 驱动程序的Hello World</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/2_qianrushidev/">第二篇 嵌入式开发基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/3_linux_kernel_api_list/">第三篇 Linux内核API汇总和各类风格总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/4_zifushebeiqudongyuanli/">第四篇 字符设备驱动实现原理和物理内存地址空间和IO端口空间</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/5_device_tree/">第五篇 platform总线模型和设备树</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/6_device_driver_sop/">第六篇 从阅读硬件手册开始设备驱动程序编写</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/7_linux_kernel_clipping/">第七篇 Linux移植</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/8_linux_driver_framework/">第八篇 Linux驱动框架和SoC驱动框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/9_linux_device_class/">第九篇 Linux设备分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/10_u_boot/">第十篇 u-boot梳理和总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/11_linux_reset_subsystem_and_framework/">第十一篇 Linux Reset子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/12_pinctl_and_gpio/">第十二篇 Linux pinctl和gpio子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/13_embedded_development_direction/">第十三篇 嵌入式开发方向和分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/14_linux_kernel_trimming/">第十四篇 Linux内核裁剪总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/15_imx6ull/">第十五篇 IMX6UL实验记录</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十五章 AI+嵌入式结合方向汇总</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_15/1_demo_of_ai/">第一篇 AI程序 Hello World</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十六章 网络安全方向</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_16/1_network_attack/">第一篇 认识各种网络攻击</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Lott's Blog</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">第六章 Linux Mem子系统</li>
      <li class="breadcrumb-item active">第四篇 Linux内存管理基础篇</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">概述</h1>
<ul>
<li>总结 Linux 内存管理原理. 讲述虚拟内存、分段、分页的进化过程.</li>
<li>计算机启动时, 分页机制必须提交准备好才可以运行真正的<code>start_kernel()</code>函数.</li>
</ul>
<h2 id="_2">虚拟内存的由来</h2>
<p>如果你是电子相关专业的，肯定在大学里捣鼓过单片机。</p>
<p>单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。</p>
<p>另外，<strong>单片机的 CPU 是直接操作内存的「物理地址」</strong>。</p>
<p><img alt="png" src="../../img/AEC36357-01E2-4C01-9B5D-D3D64E4FB289.png" /></p>
<p>在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第二个程序在 2000 的位置写入一个新的值，将会擦掉第一个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。</p>
<blockquote>
<p>操作系统是如何解决这个问题呢？</p>
</blockquote>
<p>这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。</p>
<p>我们可以把进程所使用的地址<code>「隔离」</code>开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。</p>
<p><img alt="png" src="../../img/WechatIMG289.png" /></p>
<p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p>
<p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p>
<p>于是，这里就引出了两种地址的概念：</p>
<ul>
<li>
<p>我们程序所使用的内存地址叫做<strong>虚拟内存地址（Virtual Memory Address）</strong></p>
</li>
<li>
<p>实际存在硬件里面的空间地址叫<strong>物理内存地址（Physical Memory Address）</strong>。</p>
</li>
</ul>
<p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p>
<p><img alt="png" src="../../img/WechatIMG290.jpeg" /></p>
<p>操作系统是如何管理虚拟地址与物理地址之间的关系？</p>
<p>主要有两种方式，分别是<strong>内存分段</strong>和<strong>内存分页</strong>，分段是比较早提出的，我们先来看看内存分段。</p>
<blockquote>
<p>了解分段的原理之前我们需要提前说明一些 CPU 寄存器.</p>
</blockquote>
<h3 id="cpu">著名的 CPU 寄存器</h3>
<ul>
<li>cs （代码段寄存器）</li>
<li>ss （栈段寄存器）</li>
<li>ds （数据段寄存器）</li>
<li>gdtr 寄存器, 存放 <code>全局描述符GDT（Global Descriptor Table)</code>的地址.</li>
<li>GDT 本身则存放在内存中.</li>
<li>idtr，存放中断向量表的地址. <code>中断向量表IDT(Interrupt Descriptor Table)</code> 有多行，每一行代表某一个中断号发生之后，要执行的函数.</li>
<li>IDT 本身则存放在内存中</li>
</ul>
<h2 id="_3">内存分段</h2>
<p>程序是由若干个逻辑分段组成的，如可由<code>代码分段</code>、<code>数据分段</code>、<code>栈段</code>、<code>堆段</code>组成。不同的段是有不同的属性的，所以就用<code>分段（Segmentation）</code>的形式把这些段分离出来。</p>
<p>分段机制下的虚拟地址由两部分组成，<code>段选择子</code>和<code>段内偏移量</code>。</p>
<p><img alt="png" src="../../img/WechatIMG287.jpeg" /></p>
<ul>
<li>
<p><code>段选择子</code>就保存在段寄存器里面。段选择子里面最重要的是<code>段号</code>，用作<code>段表</code>的索引。<code>段表</code>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</p>
</li>
<li>
<p>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</p>
</li>
<li>
<p>这里提到的<code>段表</code>, 就是 <code>全局描述符表GDT（Global Descriptor Table)</code>, 它的实际位置存放在内存中, CPU 的<code>gdtr寄存器</code>存放了 GDT 的地址.</p>
</li>
</ul>
<p>在上面了，知道了虚拟地址是通过<code>段表</code>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</p>
<p><img alt="png" src="../../img/D378AAAF-CF01-4568-ACD6-21EB98B1B859.png" /></p>
<p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。</p>
<h3 id="_4">如何从虚拟地址得到对应的物理地址</h3>
<p><strong>【段选择子+段偏移地址】</strong>中的<code>段选择子</code>可以认为是一个索引，这个索引指向了<code>全局段描述符表</code>中的一项，全局段描述表存储在内存中，它的起始地址存储在全局段描述符寄存器中。</p>
<p>全局段描述符表有很多个<code>段描述符</code>，每个<code>段描述符</code>占用 8 个字节，这个<code>段描述符</code>里面就包括了<code>段基址</code>，另外还有一些安全性相关的描述信息例如段的<code>可读，可写，可执行，段的大小</code>等。</p>
<p>段选择子存储在了段寄存器中，总共 16 位,其中高 13 位就是全局段描述表的索引。</p>
<p>段选择符（段选择子）结构： <img alt="png" src="../../img/3B7FB0E9-9828-44A2-9EA4-2BC635D136B0.jpg" /></p>
<p>当 CPU 开始执行代码段的第一条指令时,会将代码段的选择子放入到 CS 段寄存器中,然后 CPU 从段寄存器中的获取段选择子，然后截取选择子的高 13 位获取索引，然后根据全局描述符表寄存器的地址找到全局描述符表的起始地址，根据起始地址+索引*8 找到段描述符,然后根据段描述符获取段的基址，段的基址加上 ip 寄存器中的偏移地址就是指令的物理地址，如下图所示 1~6 步骤所示</p>
<p><img alt="png" src="../../img/WechatIMG291.jpeg" /></p>
<p>当 CPU 执行到 0x00600000 处的代码指令时，该指令为 MOV AX,[0]，该指令的意思是把地址 0 处的数据存储到 AX 寄存器，这个 0 就是数据段的偏移地址，此时 CPU 会将数据段的选择子加入到 DS 段寄存器中,然后 CPU 获取段选择的高 13 位获取索引，然后根据全局描述符表寄存器的地址找到全局描述符表的起始地址，根据起始地址+索引*8 找到段描述符,然后根据段描述符获取段的基址，段的基址加上数据段的偏移地址就是数据的物理地址，如下图 1~6 步骤所示</p>
<p><img alt="png" src="../../img/WechatIMG292.jpeg" /></p>
<h2 id="_5">分段机制的问题</h2>
<p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：</p>
<ul>
<li>
<p>第一个就是内存碎片的问题。</p>
</li>
<li>
<p>第二个就是内存交换的效率低的问题。</p>
</li>
</ul>
<blockquote>
<p>接下来，说说为什么会有这两个问题。</p>
</blockquote>
<p>我们先来看看，分段为什么会产生内存碎片的问题？</p>
<h3 id="1g">我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</h3>
<ul>
<li>
<p>游戏占用了 512MB 内存</p>
</li>
<li>
<p>浏览器占用了 128MB 内存</p>
</li>
<li>
<p>音乐占用了 256 MB 内存。</p>
</li>
</ul>
<p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。</p>
<p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p>
<p><img alt="png" src="../../img/CB8B2F7E-8138-4C76-B728-A2AC00315B0D.png" /></p>
<p>这里的内存碎片的问题共有两处地方：</p>
<ul>
<li>
<p>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；</p>
</li>
<li>
<p>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；</p>
</li>
</ul>
<p>针对上面两种内存碎片的问题，解决的方式会有所不同。</p>
<p>解决外部内存碎片的问题就是<strong>内存交换</strong>。</p>
<p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p>
<h3 id="_6">再来看看，分段为什么会导致内存交换效率低的问题？</h3>
<p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 <code>Swap 内存区域</code>，这个过程会产生性能瓶颈。</p>
<p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p>
<p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿</strong>。</p>
<p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。</p>
<h2 id="_7">内存分页</h2>
<p>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。</p>
<p>要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是<code>内存分页（Paging）</code>。</p>
<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。</strong>这样一个连续并且尺寸固定的内存空间，我们叫<code>页（Page）</code>。在 Linux 下，每一页的大小为 <code>4KB</code>。</p>
<p><code>虚拟地址</code>与<code>物理地址</code>之间通过<code>页表</code>来映射，如下图：</p>
<p><img alt="png" src="../../img/WechatIMG296.jpeg" /></p>
<p>页表实际上存储在 CPU 的<strong>内存管理单元 （MMU）</strong> 中，于是 CPU 就可以直接通过 <code>MMU</code>，找出要实际要访问的物理内存地址。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<code>缺页异常</code>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<blockquote>
<p>分页是怎么解决分段的内存碎片、内存交换效率低的问题？</p>
</blockquote>
<p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而<code>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存</code>。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<code>换出（Swap Out）</code>。一旦需要的时候，再加载进来，称为<code>换入（Swap In）</code>。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<code>内存交换的效率就相对比较高</code>。</p>
<p><img alt="png" src="../../img/WechatIMG334.jpeg" /></p>
<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<code>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去</code>。</p>
<blockquote>
<p>分页机制下，虚拟地址和物理地址是如何映射的？</p>
</blockquote>
<p>在分页机制下，虚拟地址分为两部分，<code>页号</code>和<code>页内偏移</code>。<code>页号</code>作为<code>页表</code>的索引，<code>页表</code>包含物理页每页所在<code>物理内存的基地址</code>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</p>
<p><img alt="png" src="../../img/WechatIMG335.jpeg" /></p>
<h4 id="linux">Linux 下页表</h4>
<ul>
<li>Linux 中使用<code>struct mm_struct</code>表示进程的虚拟地址空间</li>
<li><code>mm_struct</code>中有一个<code>pgd</code>域, 指向 <code>struct pgd_t</code>表示进程的页表</li>
</ul>
<p><img alt="png" src="../../img/F1382197-8D08-4D3C-82F0-F2F2BDA3BE9B.png" /></p>
<p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>
<p>把虚拟内存地址，切分成页号和偏移量；</p>
</li>
<li>
<p>根据页号，从页表里面，查询对应的物理页号；</p>
</li>
<li>
<p>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</p>
</li>
</ul>
<p>下面举个例子，虚拟内存中的页通过页表映射为了物理内存中的页，如下图：</p>
<p><img alt="png" src="../../img/WechatIMG336.jpeg" /></p>
<h3 id="_8">单极页表的问题和多级页表的引入</h3>
<p><a href="https://mp.weixin.qq.com/s/HJB_ATQFNqG82YBCRr97CA">参考 1</a>
<a href="https://mp.weixin.qq.com/s/80LjQ9o8JIZu0PxY7PgKAw?locale=zh-CN">参考 2</a></p>
<h2 id="linux_1">Linux 下段页式内存管理</h2>
<h3 id="1">1 什么是段页式内存管理</h3>
<p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p>
<p><img alt="png" src="../../img/WechatIMG539.png" /></p>
<p>段页式内存管理实现的方式：</p>
<ul>
<li>
<p>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</p>
</li>
<li>
<p>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</p>
</li>
</ul>
<p>这样，地址结构就由<code>段号</code>、<code>段内页号</code>和<code>页内位移</code>三部分组成。</p>
<p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：</p>
<p><img alt="png" src="../../img/WechatIMG540.jpeg" /></p>
<p>段页式地址变换中要得到物理地址须经过三次内存访问：</p>
<ul>
<li>
<p>第一次访问段表，得到页表起始地址；</p>
</li>
<li>
<p>第二次访问页表，得到物理页号；</p>
</li>
<li>
<p>第三次将物理页号与页内位移组合，得到物理地址。</p>
</li>
</ul>
<p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。</p>
<h3 id="2-linux">2 Linux 下的段页式内存管理</h3>
<p>那么，Linux 操作系统采用了哪种方式来管理内存呢？</p>
<blockquote>
<p>在回答这个问题前，我们得先看看 Intel 处理器的发展历史.</p>
</blockquote>
<p>早期 Intel 的处理器从 80286 开始使用的是段式内存管理。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。因此，在不久以后的 80386 中就实现了对页式内存管理。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。</p>
<p>但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，<strong>页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射。</strong></p>
<p>由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。</p>
<p><img alt="png" src="../../img/WechatIMG541.png" /></p>
<p>这里说明下逻辑地址和线性地址：</p>
<ul>
<li>
<p>程序所使用的地址，通常是没被段式内存管理映射的地址，称为<code>逻辑地址</code>；</p>
</li>
<li>
<p>通过段式内存管理映射的地址，称为<code>线性地址</code>，也叫虚拟地址；</p>
</li>
</ul>
<p><code>逻辑地址</code>是<code>「段式内存管理」</code>转换前的地址，<code>线性地址</code>则是<code>「页式内存管理」</code>转换前的地址。</p>
<h4 id="21-linux">2.1 Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。</h4>
<p>这主要是上面 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。</p>
<p>但是事实上，Linux 内核所采取的办法是使段式映射的过程实际上不起什么作用。也就是说，“上有政策，下有对策”，若惹不起就躲着走。</p>
<p>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</p>
<ul>
<li>四个主要的 Linux 段的段描述符字段的值</li>
</ul>
<table>
<thead>
<tr>
<th>段</th>
<th>Base</th>
<th>G</th>
<th>Limit</th>
<th>S</th>
<th>Type</th>
<th>DPL</th>
<th>D/B</th>
<th>P</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户代码段</td>
<td>0x00000000</td>
<td>1</td>
<td>0xfffff</td>
<td>1</td>
<td>10</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>用户数据段</td>
<td>0x00000000</td>
<td>1</td>
<td>0xfffff</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内核代码段</td>
<td>0x00000000</td>
<td>1</td>
<td>0xfffff</td>
<td>1</td>
<td>10</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内核数据段</td>
<td>0x00000000</td>
<td>1</td>
<td>0xfffff</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<ul>
<li>
<ul>
<li>相应的<code>段选择符</code>由宏<code>__USER_CS</code>,<code>__USER_DS</code>,<code>__KERNEL_CS</code>,<code>__KERNEL_DS</code>分别定义.例如, 为了对内核代码段寻址，内核只需要把<code>__KERNEL_CS</code>宏产生的值装进<code>cs段寄存器</code>即可.</li>
</ul>
</li>
<li>
<p>注意</p>
</li>
<li>
<ul>
<li>1 与段相关的线性地址都 0 开始，达到 2 的 32 次方-1 的寻址限长. 这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址.</li>
</ul>
</li>
<li>
<ul>
<li>2 所有段都从<code>0x00000000</code>开始, 表明 Linux 下<code>逻辑地址</code>与<code>线性地址</code>是一致的,即<code>逻辑地址</code>的偏移量字段的值与相应<code>线性地址</code>的值总是一致.</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们再来瞧一瞧，Linux 的虚拟地址空间是如何分布的？</p>
</blockquote>
<p>在 Linux 操作系统中，虚拟地址空间的内部又被分为<code>内核空间</code>和<code>用户空间</code>两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：</p>
<p><img alt="png" src="../../img/WechatIMG542.jpeg" /></p>
<p>通过这里可以看出：</p>
<ul>
<li>
<p>32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；</p>
</li>
<li>
<p>64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</p>
</li>
</ul>
<p>再来说说，内核空间与用户空间的区别：</p>
<ul>
<li>
<p>进程在用户态时，只能访问用户空间内存；</p>
</li>
<li>
<p>只有进入内核态后，才可以访问内核空间的内存；</p>
</li>
</ul>
<p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p>
<p><img alt="png" src="../../img/WechatIMG543.jpeg" /></p>
<p>接下来，进一步了解虚拟空间的划分情况，用户空间和内核空间划分的方式是不同的，内核空间的分布情况就不多说了。</p>
<p>我们看看用户空间分布的情况，以 32 位系统为例，我画了一张图来表示它们的关系：</p>
<p><img alt="png" src="../../img/WechatIMG544.png" /></p>
<p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 7 种不同的内存段：</p>
<ul>
<li>
<p>1 程序文件段，包括二进制可执行代码；</p>
</li>
<li>
<p>2 已初始化数据段，包括静态常量；</p>
</li>
<li>
<p>3 未初始化数据段，包括未初始化的静态变量；</p>
</li>
<li>
<p>4 堆段，包括动态分配的内存，从低地址开始向上增长；</p>
</li>
<li>
<p>5 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</p>
</li>
<li>
<p>6 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；</p>
</li>
<li>
<p>7 内存的最高端存放的是命令行参数和环境变量.</p>
</li>
</ul>
<h2 id="linux_2">Linux 下内存子系统的优化技能</h2>
<h3 id="1-ksm">1 KSM 和 透明大页的区别</h3>
<ul>
<li>
<p>如果开启 KSM，kernel 层面会有 ksmd 进程把内容完全一样的物理页进行合并，并标记为 cow (copy on write)， 以减少物理页消耗</p>
</li>
<li>
<p>透明大页的作用是:</p>
</li>
<li>
<ul>
<li>一个进程如果需要大量内存，那么底层申请的物理页可以大于 4KB，比如 16KB 一个物理页，减少虚拟地址到物理地址的映射条目，从而减少页表大小，加快虚拟地址到物理地址的翻译速度</li>
</ul>
</li>
</ul>
<h3 id="2-linux_1">2 Linux 内存子系统所有优化点罗列</h3>
<ul>
<li>（一） 节约内存</li>
<li>
<ul>
<li>1 KSM</li>
</ul>
</li>
<li>
<ul>
<li>2 父子进程的 COW（写时 Copy）</li>
</ul>
</li>
<li>
<ul>
<li>3 能够分配小于一个 page 的内存，slab 分配器</li>
</ul>
</li>
<li>
<p>（二） 提高效率</p>
</li>
<li>
<ul>
<li>1 透明大页（通过减少页表映射条目）</li>
</ul>
</li>
<li>
<ul>
<li>2 NUMBA 。让 CPU 就近访问内存</li>
</ul>
</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../3_virtual_memory/" class="btn btn-neutral float-left" title="第三篇 进程虚拟地址空间介绍"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../6_alloc_mem_apis/" class="btn btn-neutral float-right" title="第六篇 Linux内核内存分配API函数分类">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../3_virtual_memory/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../6_alloc_mem_apis/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
