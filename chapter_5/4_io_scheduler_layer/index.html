<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>第四篇 Block IO Layer(块IO层)总结 - Lott's Blog</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u7b2c\u56db\u7bc7 Block IO Layer(\u5757IO\u5c42)\u603b\u7ed3";
        var mkdocs_page_input_path = "chapter_5/4_io_scheduler_layer.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Lott's Blog
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">第一章 各种杂项基础</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/1_make_blog/">第一篇 利用Github Pages和mkdocs搭建个人博客</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/2_nginx_loadbalancing_strategy/">第二篇 Nginx的均衡策略</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/3_linux_kernel_basic/">第三篇 Linux内核基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/4_linux_kernel_mm_basic/">第四篇 Linux内核空间内存概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/5_how_kernel_call_bios/">第五篇 Linux内核调用BIOS案例</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/9_linux_arch_overall_introduction/">第九篇 Linux架构整体介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/10_virtual_machine_on_mac_m1_chip/">第十篇 Mac M1芯片电脑利用Qemu安装Debian虚拟机</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/11_nftables/">第十一篇 Debian 11以及往后版本nftables防火墙配置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/12_ansible_basic_use/">第十二篇 Ansible简单使用笔记</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/13_tty_terminal_console/">第十三篇 终端(Terminal)、TTY、PTY和控制台(Console)区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/14_qemu_use/">第十四篇 QEMU模拟各类开发板</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/15_bosun/">第十五篇 Bosun使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/16_assembler/">第十六篇 汇编语言使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/17_makefile/">第十七篇 Makefile使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/18_mysql/">第十八篇 MySQL使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/19_network_ratelimit/">第十九篇 Linux网络限速</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第二章 运维工作总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweijiazhi/">第一篇 运维的价值和目标</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweizhiyeguifan/">第二篇 业务SRE的职业规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweipingtailinian/">第三篇 运维平台建设的理念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/guzhangguanli/">第四篇 故障管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/biangengguanli/">第五篇 变更管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/rongliangguanli/">第六篇 容量管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/jiagoushisiweihetezhi/">第七篇 架构师思维和特质以及中间件技术梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/cicd/">第八篇 CICD流程概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/9_changkanchangxin/">第九篇 常看常新</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/12_monitor_and_alert/">第十二篇 监控报警最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/13_classic_thinkings/">第十三篇 经典思维</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/14_performance_optimization_topic/">第十四篇 性能优化专题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第三章 Linux Net子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/1_linux_kernel_net/">第一篇 Linux数据包接收路径梳理和常用调优技能</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/2_estab_queue_monitoring/">第二篇 Linux下如何观察完整连接队列的情况</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/3_net_ipv4_tcp_syn_retries/">第三篇 理解net.ipv4.tcp_syn_retries设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/4_linux_kernel_net_v2/">第四篇 Linux网络数据包的揭秘以及常见的调优方式总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/5_conntrack/">第五篇 conntrack的常见应用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/6_tcp/">第六篇 TCP协议总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/7_udp/">第七篇 UDP协议总结以及TCP和UDP的区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/8_io_multiplexing/">第八篇 IO多路复用总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/10_linux_net/">第十篇 Linux Net子系统总结、收发包流程再次梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/11_igb/">第十一篇 igb网卡驱动梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/12_rss_rps_rfs_xps/">第十二篇 Linux网卡rss和rps和rfs和xps</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第四章 Linux CPU子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/1_process_ulimit/">第一篇 进程Max open files的设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/2_pid_max/">第二篇 kernel源码中pid的最大值</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/3_interrupt_one/">第三篇 硬中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/5_soft_irq/">第四篇 软中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/4_process_thread_coroutine/">第五篇 进程、线程、协程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/6_cpu_famous_register/">第六篇 CPU中的著名寄存器梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/7_linux_signal/">第七篇 Linux信号机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/8_linux_scheduler/">第八篇 Linux进程调度</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/10_linux_context_switch/">第十篇 低视角看context switch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/11_linux_cpu_usage/">第十一篇 CPU利用率统计</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/12_linux_preemption/">第十二篇 内核抢占基础篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/13_interrupt_handler_examples/">第十三篇 中断处理程序的例子</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/14_linux_kernel_tracing/">第十四篇 理解内核追踪机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/15_task_struct/">第十五篇 task_struct结构体总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/16_init_call/">第十六篇 Linux各类initcall总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第五章 Linux IO子系统</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../1_four_object_of_VFS/">第一篇 VFS四大对象inode、dentry、super_block、file数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../2_io_stack/">第二篇 Linux IO栈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../3_zero_copy/">第三篇 Linux 零拷贝技术总结</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">第四篇 Block IO Layer(块IO层)总结</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#bio">一 BIO 层</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#generic-block-device-layer">Generic Block Device Layer 基础</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#1-request">1 request 结构体</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#11-request-bio">1.1 request 结构体和 bio 结构体关系</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12-gendisk-request_quque-request-bio">1.2 gendisk 结构体、request_quque 结构体、request 结构体、bio 结构体</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-bio">2 bio 结构体和写磁盘的整体过程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-bio-bio_vec">3 bio 结构体和 bio_vec 结构体关系:</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4-io-request_queue">4 I/O 请求队列: request_queue</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">二 电梯层</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1">1 核心数据结构</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#11-struct-elevator_queue">1.1 struct elevator_queue</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#12-struct-elevator_type">1.2 struct elevator_type</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#13-struct-elevator_ops">1.3 struct elevator_ops</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#14-struct-request_queue">1.4 struct request_queue</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-io">2 I/O 调度算法结构体和向内核注册</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#21">2.1 电梯排序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22-bio-request">2.2 bio 和 request 的三进三出</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#a">A 原地蓄势</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#b">B 电梯排序</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#c">C 分发执行</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">三 链路</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-vfs-bio">1 从 vfs 到 bio 层核心代码:</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">总结</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">参考</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../6_fss/">第六篇 各类文件系统梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../7_three_object_of_block_device/">第七篇 块设备三大对象block_device、gendisk、hd_struct数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../8_kobjet_kset_ktype/">第八篇 Linux设备模型的基石:kset/kobject/ktype</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../9_io_uring/">第八篇 io_uring研究和总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第六章 Linux Mem子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/1_linux_buddy/">第一篇 伙伴系统介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/2_slab/">第二篇 Slab层介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/3_virtual_memory/">第三篇 进程虚拟地址空间介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/4_linux_mem_theory/">第四篇 Linux内存管理基础篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/6_alloc_mem_apis/">第六篇 Linux内核内存分配API函数分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/7_physical_memory/">第七篇 关于物理内存管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/8_linux_mm_update/">第八篇 Linux内存管理升级篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/9_page_cache_and_buffer_cache/">第九篇 PageCache和BufferCache演进过程</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第七章 运维小技巧和工具汇总和积累</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/1_sync_file/">第一篇 不同主机之间的文件传输</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/2_sre_tools_python/">第二篇 运维生产力工具(python篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/3_sre_tools_website/">第三篇 运维生产力工具(网站工具)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/4_sre_tools_shell/">第四篇 运维生产力工具(shell篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/5_server_side_evolution/">第五篇 服务端进化过程梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/6_elk/">第六篇 elk技术栈</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/7_charset/">第七篇 字符集和编码</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/8_locale/">第八篇 locale设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/9_http_protocol/">第九篇 http协议</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/10_http_cookie_session_token/">第十篇 cookie和session和token总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第八章 职场通用经验</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/1_xuexixinde/">第一篇 学习心得和工作箴言</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/2_bangzhuqitatongxue/">第二篇 工作能力评价体系</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/3_yewuliuchengshuyu/">第三篇 项目管理总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/4_jishunenglimoxing/">第四篇 技术能力模型总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/5_chanpingsiwei_1/">第五篇 产品思维总结和梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/6_jixiaobaogao/">第六篇 如何写绩效报告</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/7_xiangshangguanli/">第七篇 如何向上管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/9_speaking_skills/">第九篇 沟通能力和演讲技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/10_jixiaofangtan/">第十篇 绩效访谈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/11_classic_technical_thinking/">第十一篇 经典技术思维汇总</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第九章 编程经验</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/1_suanfa/">第一篇 算法总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/2_data_structure/">第二篇 数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/3_c_lang/">第三篇 c语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/4_symbol_table/">第四篇 符号表总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/5_golang/">第五篇 go语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/6_linux_kernel_patch/">第六篇 手把手教你向Linux Kernel提交Patch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/7_python/">第七篇 python语言总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十章 容器化和Kubernetes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/1_dockerfile_best_practice/">第一篇 dockerfile最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/2_benefits_of_containerization/">第二篇 容器化好处</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/3_docker_basic_concepts/">第三篇 容器化基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/4_kubernetes_basic_concepts/">第四篇 Kubernetes基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/6_production_kubernetes_best_practice/">第六篇 生产环境Kubernetes部署最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/7_production_kerbernetes_yaml/">第七篇 生产环境Kubernetes YAML模版</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/8_caclio/">第八篇 Kubernetes网络插件之Caclio</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/9_cloudnative_monitor/">第九篇 云原生监控</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/10_event/">第十篇 彻底搞懂Kubernetes Event</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/11_best_practices/">第十一篇 Kubernetes最佳实践</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十一章 SRE稳定性建设从理论到实践</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/1_theory/">第一篇 稳定性概论</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/10_high_avaliable/">第二篇 高可用原则总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/2_slo_process/">第三篇 SLO实施流程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/3_stress/">第四篇 压测经验总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/11_stability/">第五篇 稳定性理论总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十二章 商业化知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_12/1_shifouzhide/">第一篇 如何判断一件事情值不值得做</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十三章 芯片知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_13/1_about_riscv/">第一篇 RISC-V 简介</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十四章 Linux驱动方向总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/1_demo_of_led_driver/">第一篇 驱动程序的Hello World</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/2_qianrushidev/">第二篇 嵌入式开发基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/3_linux_kernel_api_list/">第三篇 Linux内核API汇总和各类风格总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/4_zifushebeiqudongyuanli/">第四篇 字符设备驱动实现原理和物理内存地址空间和IO端口空间</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/5_device_tree/">第五篇 platform总线模型和设备树</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/6_device_driver_sop/">第六篇 从阅读硬件手册开始设备驱动程序编写</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/7_linux_kernel_clipping/">第七篇 Linux移植</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/8_linux_driver_framework/">第八篇 Linux驱动框架和SoC驱动框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/9_linux_device_class/">第九篇 Linux设备分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/10_u_boot/">第十篇 u-boot梳理和总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/11_linux_reset_subsystem_and_framework/">第十一篇 Linux Reset子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/12_pinctl_and_gpio/">第十二篇 Linux pinctl和gpio子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/13_embedded_development_direction/">第十三篇 嵌入式开发方向和分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/14_linux_kernel_trimming/">第十四篇 Linux内核裁剪总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/15_imx6ull/">第十五篇 IMX6UL实验记录</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十五章 AI+嵌入式结合方向汇总</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_15/1_demo_of_ai/">第一篇 AI程序 Hello World</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Lott's Blog</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>第五章 Linux IO子系统 &raquo;</li>
      <li>第四篇 Block IO Layer(块IO层)总结</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">概述</h1>
<ul>
<li>本篇汇总<strong>块 IO 层</strong>知识</li>
<li><strong>块 IO 层</strong>即下图中的<strong>Block IO Layer</strong>
  <img alt="png" src="../../img/3ae062c0-04e9-4ead-871c-1bff21e19d4a.svg" /></li>
</ul>
<p><img alt="png" src="../../img/WechatIMG626.jpg" /></p>
<p><img alt="png" src="../../img/WechatIMG628.jpg" /></p>
<p>从图中可以看出，对于磁盘的一次读请求，首先经过<strong>虚拟文件系统（VFS）</strong>，其次是<strong>页高速缓存（page cache）</strong>，接下来是<strong>映射层（mapping layer，是具体的文件系统如 ext4）</strong>、<strong>通用块层（generic block layer）</strong>、<strong>IO 调度程序（I/O scheduler，也叫 elevator）</strong>、<strong>块设备驱动（block device driver）</strong>，最后是<strong>物理块设备（block device）</strong>。</p>
<p>下面简要概括一个块设备 I/O 操作的执行过程：</p>
<ol>
<li>系统调用(如 read())的服务例程调用适当的 <strong>VFS 函数</strong>。</li>
<li>VFS 函数确定所请求的数据是否已经存在，若数据存在于内存的<strong>页高速缓存</strong>中，则直接读内存；否则进入下一步。</li>
<li>内核需要从块设备读数据，通过<strong>映射层</strong>确定数据的物理位置。</li>
<li>现在内核可以向<strong>通用块层</strong>提交请求，启动 I/O 操作来传送所请求的数据。一般而言，每个 I/O 操作只针对磁盘上一组连续的块。由于请求的数据不必位于相邻的块中，所以通用块层可能启动几次 I/O 操作。每次 I/O 操作由一个<strong>“块 I/O”(简称“bio”)</strong>结构描述，它收集底层组件需要的所有信息以满足所发出的请求。</li>
<li>通用块层下面的 <strong>I/O 调度程序</strong>根据预先定义的内核策略，<strong>将待处理的 I/O 操作（bio）映射成一个 I/O 请求（request）</strong>并插入到块设备的请求队列(request queue)中，或将一个 I/O 操作合并到队列中已有的、且物理介质上相邻的请求中。</li>
<li><strong>激活</strong>的<strong>块设备驱动程序</strong>调用策略例程(strategy routine)选择一个待处理的请求，并向磁盘控制器的硬件接口发送适当的命令，来进行实际的数据传送。</li>
<li>
<p>当 I/O 操作终止时，<strong>磁盘控制器</strong>就产生一个中断，如果需要，相应的中断程序再调用策略例程去处理队列中的另一个请求。</p>
</li>
<li>
<p>有意思的总结, Block IO Layer 分为 2 层: <strong>Generic Block Device Layer</strong>和<strong>I/O Scheduler Layer</strong>, 这两层分别可以简称为<strong>BIO 层</strong>和<strong>电梯层</strong></p>
</li>
</ol>
<h2 id="bio">一 BIO 层</h2>
<h3 id="generic-block-device-layer">Generic Block Device Layer 基础</h3>
<ul>
<li>参考《本章 第 7 篇》, Genral Block Device Layer 基础 其实就是 block_device、gendisk、hd_struct 三个核心结构体及其组成的子系统</li>
</ul>
<h3 id="1-request">1 request 结构体</h3>
<ul>
<li>每个块设备的待处理请求都是用一个结构体 request 表示的:</li>
</ul>
<pre><code>struct request {
  struct list_head queuelist; /* 用于挂在请求队列链表的节点，只能使用函数blkdev_dequeue_request访问，不能直接访问 */
  struct list_head donelist;  /* 用于挂在已完成请求链表的节点 */
  struct request_queue *q;    /* 指向请求队列的指针 */
  unsigned int cmd_flags;     /* 命令标识 */
  enum rq_cmd_type_bits cmd_type;  /* 命令类型 */

  /* 各种各样的扇区计数: */
  /* 为提交I/O维护bio横断面的状态信息，其中hard_*成员是通用块层内部更新的，驱动程序不应该修改 */
  sector_t sector;     /* 要传送的下一个扇区号 */
  sector_t hard_sector;      /* 要传送的下一个扇区号 */
  unsigned long nr_sectors;  /* 整个请求还需要传送的扇区数 */
  unsigned long hard_nr_sectors; /* 整个请求中还需要传送的扇区数 */
  unsigned int current_nr_sectors;  /* 当前bio的当前段中还需要传送的扇区数 */
  unsigned int hard_cur_sectors;    /* 当前bio的当前段中还需要传送的扇区数 */
  struct bio *bio;     /* 请求中第一个未完成传送操作的bio */
  struct bio *biotail; /* 请求链表中末尾的bio */
  struct hlist_node hash;   /* 链入一个哈希表(用来查找与新bio相邻的请求) */

  /* rb_node仅用在I/O调度器中把请求放到一棵红黑树上，当请求被移到分发队列中时，请求将被删除。 */
  /* 因此，completion_data(用于给底层驱动保存一些额外的信息)可与rb_node分享空间 */
  union {
      struct rb_node rb_node;   /* 排序/查找 */
      void *completion_data;
  };

  struct gendisk *rq_disk;    /* 请求所引用的磁盘 */
  struct hd_struct *part;     /* 请求所引用的分区 */
  unsigned long start_time;   /* 请求进入队列的时间(用jiffies表示) */

  unsigned int timeout;     /* 请求的超时 */
  int retries;

  rq_end_io_fn *end_io;   /* 请求完成时的回调函数 */
  void *end_io_data;

  // ...
};
</code></pre>
<ul>
<li>每个请求(request)包含一个或多个 bio 结构.</li>
<li>最初, 通用块层创建一个仅包含一个 bio 结构的请求.</li>
<li>然后 I/O 调度程序可能向初始的 bio 中增加一个新段, 也可能将另一个 bio 结构链接到请求中(当新数据与请求中已存在的数据物理相邻), 从而扩展该请求.</li>
<li>
<p>request 结构体中的 bio 字段指向请求中的第一个 bio 结构, 而 biotail 字段指向最后一个 bio 结构.</p>
</li>
<li>
<p>一个 request 实例中的几个成员字段值可能是动态变化的.</p>
</li>
<li>
<ul>
<li>例如一旦 bio 中引用的数据块全部传送完毕,</li>
</ul>
</li>
<li>
<ul>
<li>bio 字段立即更新从而指向请求链表中的下一个 bio.</li>
</ul>
</li>
<li>
<ul>
<li>在此期间新的 bio 可能被加入到请求链表的尾部, 所以 biotail 的指向也可能改变.</li>
</ul>
</li>
</ul>
<h4 id="11-request-bio">1.1 request 结构体和 bio 结构体关系</h4>
<p><img alt="png" src="../../img/WechatIMG625.jpg" /></p>
<h4 id="12-gendisk-request_quque-request-bio">1.2 gendisk 结构体、request_quque 结构体、request 结构体、bio 结构体</h4>
<p><img alt="png" src="../../img/WechatIMG629.jpg" /></p>
<h3 id="2-bio">2 bio 结构体和写磁盘的整体过程</h3>
<ul>
<li>首先 submit_bh()函数，其作用：根据缓冲区首部的内容创建一个 bio，在该函数中通过 buffer_head 传进来的信息对 bio 的信息赋值。如下</li>
</ul>
<pre><code>bio-&gt;bi_sector = bh-&gt;b_blocknr * (bh-&gt;b_size &gt;&gt; 9); //扇区号

bio-&gt;bi_bdev = bh-&gt;b_bdev; //设备，如分区

bio-&gt;bi_io_vec[0].bv_page = bh-&gt;b_page; //对应页

bio-&gt;bi_io_vec[0].bv_len = bh-&gt;b_size;  //块大小

bio-&gt;bi_io_vec[0].bv_offset = bh_offset(bh); //buffer_head指向的缓存区相对于其所在页的偏移
</code></pre>
<h3 id="3-bio-bio_vec">3 bio 结构体和 bio_vec 结构体关系:</h3>
<ul>
<li>bio 和 bio_vec 的关系可以参考<a href="https://blog.csdn.net/juS3Ve/article/details/79890688">文件读写（BIO）波澜壮阔的一生</a>, 如下图:</li>
<li>bio 的定义如下(include/linux/blk_types.h)</li>
</ul>
<pre><code>struct bio_vec {
       struct page    *bv_page; /* 指向这个内存缓冲区所在的物理页面 */
       unsigned int  bv_len; /* 内存缓冲区大小(字节) */
       unsigned int  bv_offset;  /* 缓冲区在该物理页面上的偏移量(字节) */

};

struct bio {
       struct bio              *bi_next; /* 请求队列中的下一个bio */
       struct block_device      *bi_bdev;  /* 相关的块设备 */
       sector_t            bi_sector;    /* 需要传输的第一个扇区号(磁盘中的位置) */
       struct bvec_iter     bi_iter;
       unsigned long        bi_flags;    /* bio标志位 */
       unsigned long        bi_rw;        /* I/O操作类型及优先级 */
       unsigned short  bi_vcnt;    /* bio_vec数组中段的数目 */
       unsigned short  bi_idx;        /* bio_vec数组中段的当前索引值 */
       /* Number of segments in this BIO after

        * physical address coalescing is performed.

        */

       unsigned int        bi_phys_segments;   /* 结合后的片段数 */
       unsigned int        bi_size;    /* 剩余的I/O数量 */
       bio_end_io_t         *bi_end_io;
       void               *bi_private;
       atomic_t        bi_cnt;           /* pin count bio的引用计数器 */

       struct bio_vec       *bi_io_vec;     /* the actual vec list */

};


</code></pre>
<ul>
<li>BIO 结构体其中最重要的几个成员变量是 bi_io_vecs、 bi_vcnt 和 bi_idx。</li>
<li>
<ul>
<li>bi_io_vecs 指向一个 bio_vec 结构体数组，该结构体数组包含了一个特定 I/O 操作所需要使用到的所有段（segment）。</li>
</ul>
</li>
<li>
<ul>
<li>每个 bio_vec 结构都是一个向量，它描述的是一个特定的<strong>段</strong>：段所在的物理页、块在物理页中的偏移量、从给定偏移量开始的块长度。</li>
</ul>
</li>
<li>
<ul>
<li>整个 bio_io_vec 结构体数组表示了一个完整的缓冲区。即使一个缓冲区分散在内存的多个位置上，bio 结构体也能对内核保证 I/O 操作的执行，这样的就叫做向量 I/O（vectored I/O，或 scatter/gather I/O）。</li>
</ul>
</li>
</ul>
<p>它是一个描述硬盘里面的位置与 page cache 的页对应关系的数据结构，<strong>每个 bio 对应的硬盘里面一块连续的位置，每一块硬盘里面连续的位置，可能对应着 page cache 的多页或者一页</strong>，所以它里面会有一个 <code>bio_vec *bi_io_vec</code> 数组(可以理解为一个 bio_vec 数组, 数组是用首元素地址表示的, 所以这里指针指向首元素即可)</p>
<p>在每个给定的块设备 I/O 操作中，bi_vcnt 域用来描述 bi_io_vec 所指向的 bio_vec 数组中的向量数目。<strong>当通用块层开始执行请求，需要使用各个片段时，bi_idx 就会不断更新，总是指向当前片段。</strong> 通用块层通过它可以跟踪块设备 I/O 操作的完成进度。</p>
<p>bio 作为通用块层的主要数据结构，既描述了操作磁盘的位置(bi_sector)，又描述了内存的位置(bi_io_vec)，是上层内核 vfs 与下层驱动的连接纽带。</p>
<p>我们现在假设 3 种情况</p>
<ul>
<li>第 1 种情况是 page_cache_sync_readahead()要读的 0~16KB 数据，在硬盘里面正好是顺序排列的(是否顺序排列，要查文件系统，如 ext3、ext4)，Linux 会为这一次 4 页的读，分配 1 个 bio 就足够了，并且让这个 bio 里面分配 4 个 bi_io_vec，指向 4 个不同的内存页：</li>
</ul>
<p><img alt="png" src="../../img/WechatIMG573.jpg" /></p>
<ul>
<li>第 2 种情况是 page_cache_sync_readahead()要读的 0~16KB 数据，在硬盘里面正好是完全不连续的 4 块 (是否顺序排列，要查文件系统，如 ext3、ext4)，Linux 会为这一次 4 页的读，分配 4 个 bio，并且让这 4 个 bio 里面，每个分配 1 个 bi_io_vec，指向 4 个不同的内存页面：</li>
</ul>
<p><img alt="png" src="../../img/WechatIMG574.jpg" /></p>
<ul>
<li>当然你还可以有第 3 种情况，比如 0~8KB 在硬盘里面连续，8~16KB 不连续，那可以是这样的:</li>
</ul>
<p><img alt="png" src="../../img/WechatIMG575.jpg" /></p>
<h3 id="4-io-request_queue">4 I/O 请求队列: request_queue</h3>
<ul>
<li>请求队列由一个大的结构体 request_queue 表示:</li>
</ul>
<pre><code>struct request_queue
{
  /*
   * Together with queue_head for cacheline sharing
   */
  struct list_head    queue_head;
  struct request        *last_merge;
  struct elevator_queue    *elevator;

  /*
   * the queue request freelist, one for reads and one for writes
   */
  struct request_list    rq;   /* 请求结构体的freelist */

  /* 不同情况下执行的回调方法： */
  request_fn_proc        *request_fn;
  make_request_fn        *make_request_fn;
  prep_rq_fn        *prep_rq_fn;
  unprep_rq_fn        *unprep_rq_fn;
  merge_bvec_fn        *merge_bvec_fn;
  softirq_done_fn        *softirq_done_fn;
  rq_timed_out_fn        *rq_timed_out_fn;
  dma_drain_needed_fn    *dma_drain_needed;
  lld_busy_fn        *lld_busy_fn;

  // ...
};

</code></pre>
<ul>
<li>请求队列（request_queue）实质上是一个双向链表，每个元素是一个请求(request 结构体).</li>
<li>request_queue 结构体中的 queue_head 成员存放链表的头。</li>
<li>结构体成员 make_request_fn 为 I/O 请求创建一个 request 结构体，然后把交给 I/O 调度程序。</li>
<li>I/O 调度程序提供了几种预先定义好的元素排序方式（调度算法），后续会详细展开说明。</li>
<li>
<p>而成员 request_fn 存放来自设备驱动程序的请求处理函数。</p>
</li>
<li>
<p>每个请求队列都有一个允许处理的最大请求数，request_queue 的 nr_requests 字段存放了每个数据传送方向所允许的最大请求数（默认读写队列的最大请求数都是 128 个）。</p>
</li>
<li>如果待处理的读/写请求数超过了允许的最大值，那么队列会被标志已满，需要把请求加入到某个传送方向的可阻塞进程被放置到 request_list 结构所对应的等待队列中睡眠。</li>
</ul>
<h2 id="_2">二 电梯层</h2>
<h3 id="1">1 核心数据结构</h3>
<p><img alt="png" src="../../img/55114748-9159-4587-9F2F-12F17A47B580.png" /></p>
<h4 id="11-struct-elevator_queue">1.1 struct elevator_queue</h4>
<pre><code>include/linux/elevator.h

/*
 * each queue has an elevator_queue associated with it
 */
struct elevator_queue
{
    struct elevator_type *type;
    void *elevator_data;
    struct kobject kobj;
    struct mutex sysfs_lock;
    unsigned int registered:1;
    DECLARE_HASHTABLE(hash, ELV_HASH_BITS);
};

</code></pre>
<h4 id="12-struct-elevator_type">1.2 struct elevator_type</h4>
<pre><code>/*
 * identifies an elevator type, such as AS or deadline
 */
struct elevator_type
{
    /* managed by elevator core */
    struct kmem_cache *icq_cache;

    /* fields provided by elevator implementation */
    struct elevator_ops ops;
    size_t icq_size;    /* see iocontext.h */
    size_t icq_align;   /* ditto */
    struct elv_fs_entry *elevator_attrs;
    char elevator_name[ELV_NAME_MAX];
    struct module *elevator_owner;

    /* managed by elevator core */
    char icq_cache_name[ELV_NAME_MAX + 5];  /* elvname + &quot;_io_cq&quot; */
    struct list_head list;
};

</code></pre>
<h4 id="13-struct-elevator_ops">1.3 struct elevator_ops</h4>
<pre><code>
struct elevator_ops
{
    elevator_merge_fn *elevator_merge_fn;
    elevator_merged_fn *elevator_merged_fn;
    elevator_merge_req_fn *elevator_merge_req_fn;
    elevator_allow_merge_fn *elevator_allow_merge_fn;
    elevator_bio_merged_fn *elevator_bio_merged_fn;

    elevator_dispatch_fn *elevator_dispatch_fn;
    elevator_add_req_fn *elevator_add_req_fn;
    elevator_activate_req_fn *elevator_activate_req_fn;
    elevator_deactivate_req_fn *elevator_deactivate_req_fn;

    elevator_completed_req_fn *elevator_completed_req_fn;

    elevator_request_list_fn *elevator_former_req_fn;
    elevator_request_list_fn *elevator_latter_req_fn;

    elevator_init_icq_fn *elevator_init_icq_fn; /* see iocontext.h */
    elevator_exit_icq_fn *elevator_exit_icq_fn; /* ditto */

    elevator_set_req_fn *elevator_set_req_fn;
    elevator_put_req_fn *elevator_put_req_fn;

    elevator_may_queue_fn *elevator_may_queue_fn;

    elevator_init_fn *elevator_init_fn;
    elevator_exit_fn *elevator_exit_fn;
};


</code></pre>
<h4 id="14-struct-request_queue">1.4 struct request_queue</h4>
<ul>
<li><code>include/linux/blkdev.h</code></li>
</ul>
<pre><code>
struct request_queue {
    /*
     * Together with queue_head for cacheline sharing
     */
    struct list_head    queue_head;
    struct request      *last_merge;
    struct elevator_queue   *elevator;
    int         nr_rqs[2];  /* # allocated [a]sync rqs */
    int         nr_rqs_elvpriv; /* # allocated rqs w/ elvpriv */

    /*
     * If blkcg is not used, @q-&gt;root_rl serves all requests.  If blkcg
     * is used, root blkg allocates from @q-&gt;root_rl and all other
     * blkgs from their own blkg-&gt;rl.  Which one to use should be
     * determined using bio_request_list().
     */
    struct request_list root_rl;

    request_fn_proc     *request_fn;
    make_request_fn     *make_request_fn;
    prep_rq_fn      *prep_rq_fn;
    unprep_rq_fn        *unprep_rq_fn;
    merge_bvec_fn       *merge_bvec_fn;
    softirq_done_fn     *softirq_done_fn;
    rq_timed_out_fn     *rq_timed_out_fn;
    dma_drain_needed_fn *dma_drain_needed;
    lld_busy_fn     *lld_busy_fn;

    struct blk_mq_ops   *mq_ops;

    unsigned int        *mq_map;

    /*省略*/
}

</code></pre>
<h3 id="2-io">2 I/O 调度算法结构体和向内核注册</h3>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s/Hc8OIhZqTAuYnVj4HAE9Ng">I/O 调度层</a>通过 elevator_ops 结构体来适配不同的 I/O 调度算法，这个结构体定义了一系列的接口。不同的 I/O 调度算法只需要实现这些接口，然后注册到 I/O 调度层后，即可被 I/O 调度层识别。</p>
</li>
<li>
<p>elevator_ops 结构体定义如下：</p>
</li>
</ul>
<pre><code>
struct elevator_ops
{
    elevator_merge_fn *elevator_merge_fn;
    elevator_merged_fn *elevator_merged_fn;
    ...
    elevator_dispatch_fn *elevator_dispatch_fn;
    elevator_add_req_fn *elevator_add_req_fn;
    ...
};

</code></pre>
<ul>
<li>
<p>elevator_ops 结构定义了很多接口，但 I/O 调度算法只需要按需实现其中部分重要的接口即可。</p>
</li>
<li>
<p>下面我们来介绍一下 elevator_ops 结构几个重要接口的作用：</p>
</li>
<li>
<ul>
<li><code>elevator_merge_fn</code>：用于判断新提交的 I/O 请求是否能够与 I/O 调度器中的请求进行合并。</li>
</ul>
</li>
<li>
<ul>
<li><code>elevator_merged_fn</code>：用于对合并后的 I/O 请求进行重新排序。</li>
</ul>
</li>
<li>
<ul>
<li><code>elevator_dispatch_fn</code>：用于将 I/O 调度器中的 I/O 请求分发给块设备驱动层。</li>
</ul>
</li>
<li>
<ul>
<li><code>elevator_add_req_fn</code>：用于向 I/O 调度器添加新的 I/O 请求。
    由于内核支持多种 I/O 调度算法，所以内核通过链表把所有的 I/O 调度算法连接起来。如果用户编写了新的 I/O 调度算法，可以使用 <code>elv_register()</code> 函数将其注册到内核中。</li>
</ul>
</li>
</ul>
<h3 id="21">2.1 <a href="https://blog.csdn.net/juS3Ve/article/details/79890688">电梯排序</a></h3>
<ul>
<li>
<p>当各个进程本地的 plug list 里面的 request 被泄洪，以排山倒海之势进入的，不是最终的设备驱动（不会直接被拍死在沙滩上的）,而是一个电梯排队算法，进行再一次的排队。这个电梯调度，其实目的 3 个：</p>
</li>
<li>
<ul>
<li>进一步的合并 request</li>
</ul>
</li>
<li>
<ul>
<li>把 request 对硬盘的访问变得顺序化</li>
</ul>
</li>
<li>
<ul>
<li>执行 QoS</li>
</ul>
</li>
<li>
<p>电梯的内部实现可以非常灵活，但是入口是 <code>elevator_add_req_fn()</code>，出口是 <code>elevator_dispatch_fn()</code>。</p>
</li>
</ul>
<h3 id="22-bio-request">2.2 bio 和 request 的三进三出</h3>
<ul>
<li><strong>bio</strong>代表正在执行的 IO 操作.</li>
<li>用于描述硬盘里面要真实操作的位置与 page cache 的页映射关系的数据结构是 bio.</li>
</ul>
<h4 id="a">A 原地蓄势</h4>
<ul>
<li>
<p>把 bio 转化为 request，把 request 放入进程本地的 plug 队列；蓄势多个 request 后，再进行泄洪。</p>
</li>
<li>
<ul>
<li>1 形成 bio 结构体时, 按照 bio_vec 数组的连续情况分配 bio 结构体数目, 比如全连续那么就分配一个 bio 结构体, 比如全都不连续则分配和 bio_vec 数组相同数量的 bio 结构体数目</li>
</ul>
</li>
<li>
<ul>
<li>2 形成 request, 按照硬盘块的连续情况, 把 bio 形成本地进程的 request 队列</li>
</ul>
</li>
</ul>
<h4 id="b">B 电梯排序</h4>
<ul>
<li>进程本地的 plug 队列的 request 进入到电梯，内核对所有进程提交过来的 request 进行再次的合并、排序，执行 QoS 的排队，之后按照 QoS 的结果，分发给块设备驱动。电梯内部的实现，可以有各种各样的队列。</li>
</ul>
<h4 id="c">C 分发执行</h4>
<ul>
<li>最终提交给设备驱动程序，执行 request。 电梯分发的 request，被设备驱动的 request_fn()挨个取出来，派发真正的硬件读写命令到硬盘。这个分发的队列，一般就是我们在块设备驱动里面见到的 request_queue 了。</li>
</ul>
<h2 id="_3">三 链路</h2>
<h3 id="1-vfs-bio">1 从 vfs 到 bio 层核心代码:</h3>
<pre><code>
sys_read -&gt; vfs_read---&gt;ext4_file_read_iter---&gt;generic_file_read_iter(page cache) ---&gt;do_generic_file_read(在do_generic_file_read函数中调用page = find_get_page(mapping, index);)

如果没有找到page，则
if (!page) {
          /* 如果page不在当前cache中，进行预读操作*/
            page_cache_sync_readahead(mapping, ra, filp, index, last_index - index);
            page = find_get_page(mapping, index);
            if (unlikely(page == NULL))
                goto no_cached_page;

}

</code></pre>
<ol>
<li><code>fs/read_write.c</code></li>
</ol>
<pre><code>
ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
{
    ssize_t ret;

    if (!(file-&gt;f_mode &amp; FMODE_READ))
        return -EBADF;
    if (!(file-&gt;f_mode &amp; FMODE_CAN_READ))
        return -EINVAL;
    if (unlikely(!access_ok(VERIFY_WRITE, buf, count)))
        return -EFAULT;

    ret = rw_verify_area(READ, file, pos, count);
    if (ret &gt;= 0) {
        count = ret;
        if (file-&gt;f_op-&gt;read)
            ret = file-&gt;f_op-&gt;read(file, buf, count, pos);
        else if (file-&gt;f_op-&gt;aio_read)
            ret = do_sync_read(file, buf, count, pos);
        else
            ret = new_sync_read(file, buf, count, pos);
        if (ret &gt; 0) {
            fsnotify_access(file);
            add_rchar(current, ret);
        }
        inc_syscr(current);
    }

    return ret;
}

EXPORT_SYMBOL(vfs_read);

</code></pre>
<ul>
<li>
<p>以 ext4 文件系统为例(fs/ext4/file.c),file-&gt;f_op-&gt;read(file, buf, count, pos) 具体函数为</p>
</li>
<li>
<p>重点是 page_cache_sync_readahead()这个函数</p>
</li>
</ul>
<pre><code>page_cache_sync_readahead()--&gt;进行预读--&gt;ondemand_readahead--&gt;__do_page_cache_readahead--&gt;read_pages--&gt;
        ret = mapping-&gt;a_ops-&gt;readpages(filp, mapping, pages, nr_pages);--&gt; 这一步其实是具体文件系统的readpages方法，对于ext4来说就是ext4_readpages函数--&gt;ext4_readpages调用ext4_mpage_readpages--&gt;在ext4_mpage_readpages中，会构造一个bio--&gt;ext4_submit_bio_read--&gt; 调用通用方法submit_bio(bio)
</code></pre>
<ol>
<li>
<p>最终具体文件系统 ext4 这里执行了 submit_bio，submit_bio 执行了 generic_make_request</p>
</li>
<li>
<p>generic_make_request 函数</p>
</li>
<li>
<p>在 generic_make_request 中会向 bio 层申请 request 请求,内核调用 generic_make_request()函数，该函数是通用块层的主要入口点</p>
</li>
</ol>
<pre><code>
blk_qc_t generic_make_request(struct bio *bio)
{
    if (current-&gt;bio_list) {
        bio_list_add(&amp;current-&gt;bio_list[0], bio);
        goto out;
    }

    bio_list_init(&amp;bio_list_on_stack[0]);
    current-&gt;bio_list = bio_list_on_stack;
    do {
        struct request_queue *q = bdev_get_queue(bio-&gt;bi_bdev);

        if (likely(blk_queue_enter(q, false) == 0)) {
            struct bio_list lower, same;

            /* Create a fresh bio_list for all subordinate requests */
            bio_list_on_stack[1] = bio_list_on_stack[0];
            bio_list_init(&amp;bio_list_on_stack[0]);
            ret = q-&gt;make_request_fn(q, bio);

        } else {
            bio_io_error(bio);
        }
        bio = bio_list_pop(&amp;bio_list_on_stack[0]);
    } while (bio);
    current-&gt;bio_list = NULL; /* deactivate */
}
</code></pre>
<ul>
<li>调用 queue 的 request_fn 方法把 request 提交给磁盘驱动进行真正的处理。</li>
</ul>
<h2 id="_4">总结</h2>
<ul>
<li>默认是走 PageCache, PageCache 和文件系统交互层函数:</li>
<li>文件系统(ext4)和 BIO 层交互函数: <code>submit_bio()</code></li>
<li>BIO 层开始函数 generic_make_request, generic_make_request 调用 q-&gt;make_request_fn(q, bio)放入 gendisk 的队列</li>
<li>BIO 层到电梯层交互函数: 待定</li>
<li>
<p>电梯层到驱动层的交互函数：就是 request_queue 的 request_fn 成员(q-&gt;request_fn = scsi_request_fn;)</p>
</li>
<li>
<p>做一个最最简短的总结:</p>
</li>
</ul>
<pre><code>ext4构造bio请求--&gt; 调用submit_bio函数--&gt;generic_make_request调用q-&gt;make_request_fn(q, bio)放入队列--&gt; 经过一系列电梯排序--&gt;然后调用q-&gt;request_fn = scsi_request_fn; 真正下发给磁盘
</code></pre>
<ul>
<li>两处史诗级函数</li>
<li>
<ul>
<li>1 构造 bio 请求的 mpage_readpages()系列函数，以 ext4 文件系统为例就是 ext4_mpage_readpages,在 ext4_mpage_readpages 中，会构造一个 bio</li>
</ul>
</li>
<li>
<ul>
<li>2 将 bio 转化为 request 的史诗级函数,这个完成“造请求”的史诗级的函数，一般是 <code>void blk_queue_bio(struct request_queue *q, struct bio *bio)</code>，位于 block/blk-core.c。</li>
</ul>
</li>
<li>
<p>submit_bio 是块层的统一接口函数，bio 是统一 IO 结构体</p>
</li>
<li>request 是块层内部的 IO 请求的结构体，bio 到 request 有一层转换，这层转换就是排序、合并的时候；</li>
<li>make_request_fn 就是 bio 转换成 request 的时机，IO 的排序、合并时机就在于此；</li>
<li>request_fn 是 request 派发的时机，IO 的调度算法也在此发挥作用。从 request 队列中按照策略选一个 req 出来，封装成底层想要的样子，下发下去</li>
<li>IO 调度器合并、排序，包括按照电梯直上直下派发请求的目的是减少磁盘寻址时间，从而提高整体性能；</li>
<li>
<ul>
<li>noop，cfq，deadline 三种派发请求的算法都有适用自己的场景。- - noop 是几乎 bypass 请求，没有重拍、合并。deadline 是电梯算法衍生了一下。cfq 是全新的一种公平算法，跟电梯没啥关系；</li>
</ul>
</li>
<li>块层最核心的逻辑是：bio 请求怎么入队，request 请求怎么出队而已，它远比文件系统要简单；</li>
</ul>
<h2 id="_5">参考</h2>
<ul>
<li>
<p><a href="https://stardust-blog.cn/%E7%AC%94%E8%AE%B0/iostat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Linux 通用块层及 iostat 学习笔记</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/frank_zyp/article/details/88853932">linux 文件系统四 VFS 数据读取 vfs_read</a></p>
</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../3_zero_copy/" class="btn btn-neutral float-left" title="第三篇 Linux 零拷贝技术总结"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../6_fss/" class="btn btn-neutral float-right" title="第六篇 各类文件系统梳理">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../3_zero_copy/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../6_fss/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
