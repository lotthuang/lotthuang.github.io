<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>第十二篇 内核抢占基础篇 - Lott's Blog</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u7b2c\u5341\u4e8c\u7bc7 \u5185\u6838\u62a2\u5360\u57fa\u7840\u7bc7";
        var mkdocs_page_input_path = "chapter_4/12_linux_preemption.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Lott's Blog
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">第一章 各种杂项基础</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/1_make_blog/">第一篇 利用Github Pages和mkdocs搭建个人博客</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/2_nginx_loadbalancing_strategy/">第二篇 Nginx的均衡策略</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/3_linux_kernel_basic/">第三篇 Linux内核基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/4_linux_kernel_mm_basic/">第四篇 Linux内核空间内存概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/5_how_kernel_call_bios/">第五篇 Linux内核调用BIOS案例</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/9_linux_arch_overall_introduction/">第九篇 Linux架构整体介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/10_virtual_machine_on_mac_m1_chip/">第十篇 Mac M1芯片电脑利用Qemu安装Debian虚拟机</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第二章 运维工作总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweijiazhi/">第一篇 运维的价值和目标</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweizhiyeguifan/">第二篇 业务SRE的职业规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweipingtailinian/">第三篇 运维平台建设的理念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/guzhangguanli/">第四篇 故障管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/biangengguanli/">第五篇 变更管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/rongliangguanli/">第六篇 容量管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/jiagoushisiweihetezhi/">第七篇 架构师思维和特质以及中间件技术梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/cicd/">第八篇 CICD流程概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/9_changkanchangxin/">第九篇 常看常新</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/12_monitor_and_alert/">第十二篇 监控报警最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/13_classic_thinkings/">第十三篇 经典思维</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/14_performance_optimization_topic/">第十四篇 性能优化专题</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第三章 Linux Net子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/1_linux_kernel_net/">第一篇 Linux数据包接收路径梳理和常用调优技能</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/2_estab_queue_monitoring/">第二篇 Linux下如何观察完整连接队列的情况</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/3_net_ipv4_tcp_syn_retries/">第三篇 理解net.ipv4.tcp_syn_retries设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/4_linux_kernel_net_v2/">第四篇 Linux网络数据包的揭秘以及常见的调优方式总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/5_conntrack/">第五篇 conntrack的常见应用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/6_tcp/">第六篇 TCP协议总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/7_udp/">第七篇 UDP协议总结以及TCP和UDP的区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/8_io_multiplexing/">第八篇 IO多路复用总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/9_linux_send_msg/">第九篇 Linux Net子系统实现原理</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第四章 Linux CPU子系统</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../1_process_ulimit/">第一篇 进程Max open files的设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../2_pid_max/">第二篇 kernel源码中pid的最大值</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../3_interrupt_one/">第三篇 硬中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../5_soft_irq/">第四篇 软中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../4_process_thread_coroutine/">第五篇 进程、线程、协程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../6_cpu_famous_register/">第六篇 CPU中的著名寄存器梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../7_linux_signal/">第七篇 Linux信号机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../8_linux_scheduler/">第八篇 Linux进程调度</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../10_linux_context_switch/">第十篇 低视角看context switch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../11_linux_cpu_usage/">第十一篇 CPU利用率统计</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">第十二篇 内核抢占基础篇</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">一 什么是内核抢占？</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-preemption">1 先理解抢占 (preemption) 这个概念：</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-multitasking-operating-system-2">2 根据是否可以支持抢占，多任务操作系统 (multitasking operating system) 分为 2 类：</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-2">3 抢占的核心操作包括 2 个步骤：</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#4-2">4 根据抢占时机点的不同，抢占分为 2 种类型：</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">二 为什么要引入内核抢占？</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1">1 根本原因：</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-linux-3-preemption-model">2 为了让用户根据自己的需求进行配置，Linux 提供了 3 种 Preemption Model。</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#a-config_preempt_noney-model-server">A CONFIG_PREEMPT_NONE=y：不允许内核抢占，吞吐量最大的 Model，一般用于 Server 系统。</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#b-config_preempt_voluntaryy-cond_resched-cpu">B CONFIG_PREEMPT_VOLUNTARY=y：在一些耗时较长的内核代码中主动调用 cond_resched()让出 CPU，对吞吐量有轻微影响，但是系统响应会稍微快一些。</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#c-config_preempty-spinlock-critical-section-desktop-embedded">C CONFIG_PREEMPT=y：除了处于持有 spinlock 时的 critical section，其他时候都允许内核抢占，响应速度进一步提升，吞吐量进一步下降，一般用于 Desktop / Embedded 系统。</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#d-model-config_preempt_rt">D 另外，还有一个没有合并进主线内核的 Model: CONFIG_PREEMPT_RT</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">三 怎么操作?</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1_1">1 抢占前检查</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_5">抢占的发生要同时满足两个条件：</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#1_2">1、是否需要抢占？</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2">2、是否能抢占？</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-tif_need_resched-1">2 什么场景会设置需要抢占 (TIF_NEED_RESCHED = 1)</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1_3">1、周期性的时钟中断</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2_1">2、唤醒进程的时候</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#3">3、新进程创建的时候</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#4-nice">4、进程修改 nice 值的时候</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-preempt_count-0">3 什么场景下要禁止内核抢占 (preempt_count &gt; 0)</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1-per-cpu-data-structures">1、访问 Per-CPU data structures 的时候</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2-cpu-state">2、访问 CPU state 的时候</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#3-spinlock">3、持有 spinlock 的时候</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4">4 真正执行抢占的地方</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#a-user-preemption">A 执行 user preemption</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#b-kernel-preemption">B 执行 kernel preemption</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../13_interrupt_handler_examples/">第十三篇 中断处理程序的例子</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../14_linux_kernel_tracing/">第十四篇 理解内核追踪机制</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第五章 Linux IO子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/1_four_object_of_VFS/">第一篇 VFS四大对象inode、dentry、super_block、file数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/2_io_stack/">第二篇 Linux IO栈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/3_zero_copy/">第三篇 Linux 零拷贝技术总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/4_io_scheduler_layer/">第四篇 I/O调度层总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/5_fs_only_in_kernel/">第五篇 仅在内核空间可见的文件系统梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/6_fss/">第六篇 各类文件系统梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/7_three_object_of_block_device/">第七篇 块设备三大对象block_device、gendisk、hd_struct数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/8_kobjet_kset_ktype/">第八篇 Linux设备模型的基石:kset/kobject/ktype</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第六章 Linux Mem子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/1_linux_buddy/">第一篇 伙伴系统介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/2_slab/">第二篇 Slab层介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/3_virtual_memory/">第三篇 进程虚拟地址空间介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/4_linux_mem_theory/">第四篇 Linux内存管理原理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/5_buffers_cached/">第五篇 Free命令中buffers和cached区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/6_alloc_mem_apis/">第六篇 Linux内核内存分配API函数分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/7_physical_memory/">第七篇 关于物理内存管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/8_linux_mm_update/">第八篇 Linux内存管理总结升级</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第七章 运维小技巧和工具汇总和积累</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/1_sync_file/">第一篇 不同主机之间的文件传输</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/2_sre_tools_python/">第二篇 运维生产力工具(python篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/3_sre_tools_website/">第三篇 运维生产力工具(网站工具)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/4_sre_tools_shell/">第四篇 运维生产力工具(shell篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/5_server_side_evolution/">第五篇 服务端进化过程梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/6_elk/">第六篇 elk技术栈</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/7_charset/">第七篇 字符集和编码</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/8_locale/">第八篇 locale设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/9_http_protocol/">第九篇 http协议</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/10_http_cookie_session_token/">第十篇 cookie和session和token总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第八章 职场通用经验</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/1_xuexixinde/">第一篇 学习心得和工作箴言</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/2_bangzhuqitatongxue/">第二篇 工作能力评价体系</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/3_yewuliuchengshuyu/">第三篇 项目管理总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/4_jishunenglimoxing/">第四篇 技术能力模型总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/5_chanpingsiwei_1/">第五篇 产品思维总结和梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/6_jixiaobaogao/">第六篇 如何写绩效报告</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/7_xiangshangguanli/">第七篇 如何向上管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/9_speaking_skills/">第九篇 沟通能力和演讲技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/10_jixiaofangtan/">第十篇 绩效访谈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/11_classic_technical_thinking/">第十一篇 经典技术思维汇总</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第九章 编程经验</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/1_suanfa/">第一篇 算法总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/2_data_structure/">第二篇 数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/3_c_lang/">第三篇 c语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/4_symbol_table/">第四篇 符号表总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/5_golang/">第五篇 go语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/6_linux_kernel_patch/">第六篇 手把手教你向Linux Kernel提交Patch</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十章 容器化和Kubernetes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/1_dockerfile_best_practice/">第一篇 dockerfile最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/2_benefits_of_containerization/">第二篇 容器化的好处</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/3_docker_basic_concepts/">第三篇 一些基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/4_kubernetes_basic_concepts/">第四篇 Kubernetes基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/5_kubernetes_monitor/">第五篇 Kubernetes监控</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/6_production_kubernetes_best_practice/">第六篇 生产环境Kubernetes部署最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/7_production_kerbernetes_yaml/">第七篇 生产环境Kubernetes YAML模块</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十一章 SRE稳定性建设从理论到实践</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/1_theory/">第一篇 稳定性概论</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/10_high_avaliable/">第二篇 高可用原则总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/2_slo_process/">第三篇 SLO实施流程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/3_stress/">第四篇 压测经验总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/11_stability/">第五篇 稳定性理论总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十二章 商业化知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_12/1_shifouzhide/">第一篇 如何判断一件事情值不值得做</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十三章 芯片知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_13/1_about_riscv/">第一篇 RISC-V 简介</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十四章 Linux驱动方向总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/1_demo_of_led_driver/">第一篇 驱动程序的Hello World</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/2_qianrushidev/">第二篇 嵌入式开发基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/3_linux_kernel_api_list/">第三篇 Linux内核API汇总和各类风格总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/4_zifushebeiqudongyuanli/">第四篇 字符设备驱动实现原理和物理内存地址空间和IO端口空间</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/5_device_tree/">第五篇 platform总线模型和设备树</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/6_device_driver_sop/">第六篇 从阅读硬件手册开始设备驱动程序编写</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/7_linux_kernel_clipping/">第七篇 Linux移植</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/8_linux_driver_framework/">第八篇 Linux驱动框架和SoC驱动框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/9_linux_device_class/">第九篇 Linux设备分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/10_u_boot/">第十篇 u-boot梳理和总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/11_linux_reset_subsystem_and_framework/">第十一篇 Linux Reset子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/12_pinctl_and_gpio/">第十二篇 Linux pinctl和gpio子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/13_embedded_development_direction/">第十三篇 嵌入式开发方向和分类</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Lott's Blog</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>第四章 Linux CPU子系统 &raquo;</li>
      <li>第十二篇 内核抢占基础篇</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">概述</h1>
<ul>
<li>本篇汇总一些 Linux 内核抢占(preemption)的<a href="https://mp.weixin.qq.com/s/DGTCOh0T4_6QgsYe8oXWkQ">基础知识</a>, 方便大家理解内核抢占</li>
<li>
<ul>
<li>总体思路仍然是: <strong>是什么</strong>, <strong>有啥好</strong>, <strong>怎么办</strong></li>
</ul>
</li>
<li>
<p>通过 <code>grep resched_curr</code> 可以找出大多数标记抢占的场景, 这个技能也是通用：</p>
</li>
<li>
<ul>
<li>根据内核 API 来找场景. 这里内核 API <code>resched_curr</code> 是用于标记抢占的, 那么对内核源码进行<code>grep resched_curr</code> 就可以找出大多数标记抢占的场景.</li>
</ul>
</li>
</ul>
<h2 id="_2">一 什么是内核抢占？</h2>
<p>别急，咱们慢慢来。</p>
<h3 id="1-preemption">1 先理解抢占 (preemption) 这个概念：</h3>
<blockquote>
<p>involuntarily suspending a running process is called preemption</p>
</blockquote>
<p>夺取一个进程的 cpu 使用权的行为就叫做抢占。</p>
<h3 id="2-multitasking-operating-system-2">2 根据是否可以支持抢占，多任务操作系统 (multitasking operating system) 分为 2 类：</h3>
<p>1、cooperative multitasking os</p>
<p>这种 os，进程会一直运行直到它自愿停下来。这种自愿停止运行自己的行为称为 yielding。协作式多任务系统，一听就知道这是一个乌托邦式的系统，只有当所有进程都很 nice 并乐意经常 yielding 时，系统才能正常工作。如果某个进程太傻或者太坏，系统很快就完蛋了。</p>
<p>2、preemptive multitasking os</p>
<p>这种 os，会有一个调度器 (scheduler，其实就是一段用于调度进程的程序)，scheduler 决定进程何时停止运行以及新进程何时开始运行。当一个进程的 cpu 使用权被 scheduler 分配给另一个进程时，就称前一个进程被抢占了。</p>
<p>你可以把 sheduler 想象成非常智能的交警，交警按照一定的交通规则、当前的交通状况以及车辆的优先级 (救护车之类的)，决定了哪些车可以行驶、哪些车要停下来等待。</p>
<p>很明显，现阶段，preemptive os 优于 cooperative os。所以 Linux 被设计成 preemptive。</p>
<h3 id="3-2">3 抢占的核心操作包括 2 个步骤：</h3>
<p>1、从用户态陷入到内核态 (trap kernel)，3 个路径：</p>
<pre><code>
a. 系统调用，本质是 soft interrupt，通常就是一条硬件指令 (x86 的 int 0x80)。

b. 硬件中断，最典型的就是会周期性发生的 timer 中断，或者其他各种外设中断.

c. exception，例如 page fault、div 0。

</code></pre>
<p><img alt="png" src="../../img/WechatIMG196.png" /></p>
<p>2、陷入到内核态后，在合适的时机下，调用 sheduler 选出一个最重要的进程，如果被选中的不是当前正在运行的进程的话，就会执行 context switch 切换到新的进程。</p>
<h4 id="4-2">4 根据抢占时机点的不同，抢占分为 2 种类型：</h4>
<p>1、user preemption</p>
<p>这里的 user 并不是指在 user-space 里进行抢占，而是指在返回 user-space 前进行抢占，具体的：</p>
<pre><code>
When returning to user-space from a system call

When returning to user-space from an interrupt handler

</code></pre>
<p>即从 system call 和 interrupt handler 返回到 user-space 前进行抢占，这时仍然是在 kernel-space 里，抢占是需要非常高的权限的事情，user-space 没权利也不应该干这事。</p>
<p>2、kernel preemption</p>
<p>Linux 2.6 之前是不支持内核抢占的。这意味着当处于用户空间的进程请求内核服务时，在该进程阻塞（进入睡眠）等待某事（通常是 I/O）或系统调用完成之前，不能调度其他进程。支持内核抢占意味着当一个进程在内核里运行时，另一个进程可以抢占第一个进程并被允许运行，即使第一个进程尚未完成其在内核里的工作。</p>
<ul>
<li>支持内核抢占(左) vs 不支持内核抢占(右):</li>
</ul>
<p><img alt="png" src="../../img/WechatIMG197.png" /></p>
<ul>
<li>举个例子：</li>
</ul>
<p><img alt="png" src="../../img/WechatIMG198.jpeg" /></p>
<p>在上图中，进程 A 已经通过系统调用进入内核，也许是对设备或文件的 write() 调用。内核代表进程 A 执行时，具有更高优先级的进程 B 被中断唤醒。内核抢占进程 A 并将 CPU 分配给进程 B，即使进程 A 既没有阻塞也没有完成其在内核里的工作。</p>
<p>内核抢占的时机：</p>
<pre><code>
When an interrupt handler exits, before returning to kernel-space

When kernel code becomes preemptible again

If a task in the kernel explicitly calls schedule()

If a task in the kernel blocks (which results in a call to schedule() )

</code></pre>
<h2 id="_3">二 为什么要引入内核抢占？</h2>
<h3 id="1">1 根本原因：</h3>
<p><strong>trade-offs between latency and throughput</strong></p>
<p>在系统延迟和吞吐量之间进行权衡。</p>
<p>并不是说内核抢占就是绝对的好，使用什么抢占机制最优是跟你的应用场景挂钩的。如果不是为了满足用户，内核其实是完全不想进行进程切换的，因为每一次 context switch，都会有 overhead，这些 overhead 就是对 cpu 的浪费，意味着吞吐量的下降。</p>
<p>但是，如果你想要系统的响应性好一点，就得尽量多的允许抢占的发生，这是 Linux 作为一个通用操作系统所必须支持的。当你的系统做到随时都可以发生抢占时，系统的响应性就会非常好。</p>
<h3 id="2-linux-3-preemption-model">2 为了让用户根据自己的需求进行配置，Linux 提供了 3 种 Preemption Model。</h3>
<p><img alt="png" src="../../img/WechatIMG199.jpeg" /></p>
<h4 id="a-config_preempt_noney-model-server">A CONFIG_PREEMPT_NONE=y：不允许内核抢占，吞吐量最大的 Model，一般用于 Server 系统。</h4>
<p><img alt="png" src="../../img/WechatIMG200.png" /></p>
<h4 id="b-config_preempt_voluntaryy-cond_resched-cpu">B CONFIG_PREEMPT_VOLUNTARY=y：在一些耗时较长的内核代码中主动调用 cond_resched()让出 CPU，对吞吐量有轻微影响，但是系统响应会稍微快一些。</h4>
<p><img alt="png" src="../../img/WechatIMG201.png" /></p>
<h4 id="c-config_preempty-spinlock-critical-section-desktop-embedded">C CONFIG_PREEMPT=y：除了处于持有 spinlock 时的 critical section，其他时候都允许内核抢占，响应速度进一步提升，吞吐量进一步下降，一般用于 Desktop / Embedded 系统。</h4>
<p><img alt="png" src="../../img/WechatIMG202.png" /></p>
<h4 id="d-model-config_preempt_rt">D 另外，还有一个没有合并进主线内核的 Model: CONFIG_PREEMPT_RT</h4>
<ul>
<li>这个模式几乎将所有的 spinlock 都换成了 preemptable mutex，只剩下一些极其核心的地方仍然用禁止抢占的 spinlock，所以基本可以认为是随时可被抢占。</li>
</ul>
<p><img alt="png" src="../../img/WechatIMG203.png" /></p>
<h2 id="_4">三 怎么操作?</h2>
<h3 id="1_1">1 抢占前检查</h3>
<p>这里的检查是同时针对所有的 preemption 的。如果你理解了前面的 4 种 preempiton model 的话，应该能感觉到其实是不用太严格区分 user / kernel preemption，所有抢占的作用和性质都一样：降低 lantency，完全可以将它们一视同仁。</p>
<h4 id="_5">抢占的发生要同时满足两个条件：</h4>
<ul>
<li>需要抢占;</li>
<li>能抢占;</li>
</ul>
<h4 id="1_2">1、是否需要抢占？</h4>
<p>判断是否需要抢占的依据是：thread_info 的成员 flags 是否设置了 TIF_NEED_RESCHED 标志位。</p>
<p>相关的 API：</p>
<ul>
<li>set_tsk_need_resched() 用于设置该 flag。</li>
<li>tif_need_resched() 被用来判断该 flag 是否置位。</li>
<li>resched_curr(struct rq *rq)，标记当前 runqueue 需要抢占。</li>
</ul>
<h4 id="2">2、是否能抢占？</h4>
<ul>
<li>抢占发生的前提是要确保此次抢占是安全的 (preempt-safe)。</li>
<li><strong>什么才是 preempt-safe：</strong>不产生 race condition / deadlock。</li>
</ul>
<p>值得注意的是，只有 <code>kernel preemption</code> 才有被禁止的可能，而<code>user preemption</code> 总是被允许，因此这时马上就要返回 user space 了，肯定是处于一个可抢占的状态了。</p>
<p>在引入内核抢占机制的同时引入了为 thread_info 添加了新的成员：preempt_count ，用来保证抢占的安全性，获取锁时会增加 preempt_count，释放锁时则会减少。抢占前会检查 preempt_count 是否为 0，为 0 才允许抢占。</p>
<p>相关的 API：</p>
<ul>
<li>preempt_enable()，使能内核抢占，可嵌套调用。</li>
<li>preempt_disable()，关闭内核抢占，可嵌套调用。</li>
<li>preempt_count()，返回 preempt_count。</li>
</ul>
<h3 id="2-tif_need_resched-1">2 什么场景会设置需要抢占 (TIF_NEED_RESCHED = 1)</h3>
<p><strong>通过 grep resched_curr 可以找出大多数标记抢占的场景。</strong></p>
<p>下面列举的是几个我比较关心的场景。</p>
<h4 id="1_3">1、周期性的时钟中断</h4>
<p>时钟中断处理函数会调用 scheduler_tick()，它通过调度类(scheduling class) 的 task_tick 方法 检查进程的时间片是否耗尽，如果耗尽则标记需要抢占：</p>
<pre><code>
// kernel/sched/core.c
void scheduler_tick(void)
{
[...]
curr-&gt;sched_class-&gt;task_tick(rq, curr, 0);
[...]
}

</code></pre>
<p>Linux 的调度策略被封装成调度类，例如 CFS、Real-Time。CFS 调度类的 task_tick() 如下：</p>
<pre><code>
// kernel/sched/fair.c
task_tick_fair()
-&gt; entity_tick()
-&gt; resched_curr(rq_of(cfs_rq));

</code></pre>
<h4 id="2_1">2、唤醒进程的时候</h4>
<p>当进程被唤醒的时候，如果优先级高于 CPU 上的当前进程，就会触发抢占。相应的内核代码中，try_to_wake_up() 最终通过 check_preempt_curr() 检查是否标记需要抢占：</p>
<pre><code>
// kernel/sched/core.c
void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
{
 const struct sched_class *class;

 if (p-&gt;sched_class == rq-&gt;curr-&gt;sched_class) {
      rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags);
 } else {
      for_each_class(class) {
           if (class == rq-&gt;curr-&gt;sched_class)
                break;
           if (class == p-&gt;sched_class) {
                resched_curr(rq);
                break;
           }
      }
   }
   [...]
}

</code></pre>
<ul>
<li>参数 "p" 指向被唤醒进程</li>
<li>"rq" 代表抢占的 CPU。</li>
<li>
<p>如果 p 的调度类和 rq 当前的调度类相同，则调用 rq 当前的调度类的 check_preempt_curr() (例如 cfs 的 check_preempt_wakeup()) 来判断是否要标记需要抢占。</p>
</li>
<li>
<p>如果 p 的调度类 &gt; rq 当前的调度类，则用 resched_curr() 标记需要抢占，反之，则不标记。</p>
</li>
</ul>
<h4 id="3">3、新进程创建的时候</h4>
<p>如果新进程的优先级高于 CPU 上的当前进程，会需要触发抢占。相应的代码是 sched_fork()，它再通过调度类的 task_fork() 标记需要抢占：</p>
<pre><code>
// kernel/sched/core.c
int sched_fork(unsigned long clone_flags, struct task_struct \*p)
{
[...]
if (p-&gt;sched_class-&gt;task_fork)
p-&gt;sched_class-&gt;task_fork(p);
[...]
}

// kernel/sched/fair.c
static void task_fork_fair(struct task_struct \*p)
{
　[...]
　 if (sysctl_sched_child_runs_first &amp;&amp; curr &amp;&amp; entity_before(curr, se)) {
　　 resched_curr(rq);
}
[...]
}

</code></pre>
<h4 id="4-nice">4、进程修改 nice 值的时候</h4>
<p>如果修改进程 nice 值导致优先级高于 CPU 上的当前进程，也要标记需要抢占，代码见 set_user_nice()。</p>
<pre><code>
// kernel/sched/core.c
void set_user_nice(struct task_struct \*p, long nice)
{
[...]
// If the task increased its priority or is running and lowered its priority, then reschedule its CPU
if (delta &lt; 0 || (delta &gt; 0 &amp;&amp; task_running(rq, p)))
resched_curr(rq);
}

</code></pre>
<p>还有很多场景，这里就不一一列举了。</p>
<h3 id="3-preempt_count-0">3 什么场景下要禁止内核抢占 (preempt_count &gt; 0)</h3>
<p>有几种场景是明确需要关闭内核抢占的。</p>
<h4 id="1-per-cpu-data-structures">1、访问 Per-CPU data structures 的时候</h4>
<p>看下面这个例子：</p>
<pre><code>
struct this_needs_locking tux[NR_CPUS];
tux[smp_processor_id()] = some_value;
/_ task is preempted here... _/
something = tux[smp_processor_id()];

</code></pre>
<p>如果抢占发生在注释所在的那一行，当进程再次被调度时，smp_processor_id() 值可能已经发生变化了，这种场景下需要通过禁止内核抢占来做到 preempt safe。</p>
<h4 id="2-cpu-state">2、访问 CPU state 的时候</h4>
<p>这个很好理解，你正在操作 CPU 相关的寄存器以进行 context switch 时，肯定是不能再允许抢占。</p>
<pre><code>
asmlinkage **visible void **sched schedule(void)
{
struct task_struct \*tsk = current;

sched_submit_work(tsk);
do {
// 调度前禁止内核抢占
preempt_disable();
\_\_schedule(false);
sched_preempt_enable_no_resched();
} while (need_resched());
sched_update_worker(tsk);
}

</code></pre>
<h4 id="3-spinlock">3、持有 spinlock 的时候</h4>
<p>支持内核抢占，这意味着进程有可能与被抢占的进程在相同的 critical section 中运行。为防止这种情况，当持有自旋锁时，要禁止内核抢占。</p>
<pre><code>
static inline void \__raw_spin_lock(raw_spinlock_t \*lock)
{
preempt_disable();
spin_acquire(&amp;lock-&gt;dep_map, 0, 0, \_RET_IP_);
LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
}

</code></pre>
<p>还有很多场景，这里就不一一列举了。</p>
<h3 id="4">4 真正执行抢占的地方</h3>
<p>这部分是 platform 相关的，下面以 ARM64 Linux-5.4 为例，快速看下执行抢占的具体代码。</p>
<h4 id="a-user-preemption">A 执行 user preemption</h4>
<h5 id="a">a 系统调用和中断返回用户空间的时候：</h5>
<p>它们都是在 ret_to_user() 里判断是否执行用户抢占。</p>
<pre><code>
// arch/arm64/kernel/entry.S
ret_to_user() // 返回到用户空间
work_pending()
do_notify_resume()
schedule()

// arch/arm64/kernel/signal.c
asmlinkage void do_notify_resume(struct pt_regs \*regs,
unsigned long thread_flags)
{
do {
[...]
// 检查是否要需要调度
if (thread_flags &amp; \_TIF_NEED_RESCHED) {
local_daif_restore(DAIF_PROCCTX_NOIRQ);
schedule();
} else {
[...]
} while (thread_flags &amp; \_TIF_WORK_MASK);
}

</code></pre>
<h4 id="b-kernel-preemption">B 执行 kernel preemption</h4>
<h5 id="a_1">a 中断返回内核空间的时候：</h5>
<pre><code>// arch/arm64/kernel/entry.S
el1_irq
irq_handler
arm64_preempt_schedule_irq
preempt_schedule_irq
\_\_schedule(true)

// kernel/sched/core.c
/_ This is the entry point to schedule() from kernel preemption _/
asmlinkage **visible void **sched preempt_schedule_irq(void)
{
[...]
do {
preempt_disable();
local_irq_enable();
\_\_schedule(true);
local_irq_disable();
sched_preempt_enable_no_resched();
} while (need_resched());

exception_exit(prev_state);
}

</code></pre>
<h5 id="b">b 内核恢复为可抢占的时候：</h5>
<p>前面列举了集中关闭抢占的场景，当离开这些场景时，会恢复内核抢占。</p>
<p>例如 spinlock unlock 时：</p>
<pre><code>
static inline void \__raw_spin_unlock(raw_spinlock_t \*lock)
{
spin_release(&amp;lock-&gt;dep_map, 1, \_RET_IP_);
do_raw_spin_unlock(lock);
preempt_enable(); // 使能抢占时，如果需要，就会执行抢占
}

// include/linux/preempt.h
#define preempt_enable() \
do { \
 barrier(); \
 if (unlikely(preempt_count_dec_and_test())) \
 \_\_preempt_schedule(); \
} while (0)

</code></pre>
<h5 id="c">c 内核显式地要求调度的时候：</h5>
<p>内核里有大量的地方会显式地要求进行调度，最常见的是：cond_resched() 和 sleep()类函数，它们最终都会调用到 __schedule()。</p>
<h5 id="d">d 内核阻塞的时候：</h5>
<p>例如 mutex，sem，waitqueue 获取不到资源，或者是等待 IO。</p>
<p>这种情况下进程会将自己的状态从　 TASK_RUNNING 修改为 TASK_INTERRUPTIBLE，然后调用 schedule() 主动让出 CPU 并等待唤醒。</p>
<pre><code>
// block/blk-core.c
static struct request *get_request(struct request_queue *q, int op,
int op_flags, struct bio \*bio,
gfp_t gfp_mask)
{
[...]
prepare_to_wait_exclusive(&amp;rl-&gt;wait[is_sync], &amp;wait,
TASK_UNINTERRUPTIBLE);
io_schedule(); // 会调用 schedule();
[...]
}

</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../11_linux_cpu_usage/" class="btn btn-neutral float-left" title="第十一篇 CPU利用率统计"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../13_interrupt_handler_examples/" class="btn btn-neutral float-right" title="第十三篇 中断处理程序的例子">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../11_linux_cpu_usage/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../13_interrupt_handler_examples/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
