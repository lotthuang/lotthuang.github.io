<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>第八篇 Kubernetes网络插件之Calico - Lott's Blog</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u7b2c\u516b\u7bc7 Kubernetes\u7f51\u7edc\u63d2\u4ef6\u4e4bCalico";
        var mkdocs_page_input_path = "chapter_10/8_Calico.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Lott's Blog
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">第一章 各种杂项基础</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/1_make_blog/">第一篇 利用Github Pages和mkdocs搭建个人博客</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/2_nginx_loadbalancing_strategy/">第二篇 Nginx的均衡策略</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/3_linux_kernel_basic/">第三篇 Linux内核基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/4_linux_kernel_mm_basic/">第四篇 Linux内核空间内存概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/5_how_kernel_call_bios/">第五篇 Linux内核调用BIOS案例</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/9_linux_arch_overall_introduction/">第九篇 Linux架构整体介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/10_virtual_machine_on_mac_m1_chip/">第十篇 Mac M1芯片电脑利用Qemu安装Debian虚拟机</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/11_nftables/">第十一篇 Debian 11以及往后版本nftables防火墙配置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/12_ansible_basic_use/">第十二篇 Ansible简单使用笔记</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/13_tty_terminal_console/">第十三篇 终端(Terminal)、TTY、PTY和控制台(Console)区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/14_qemu_use/">第十四篇 QEMU模拟各类开发板</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/15_bosun/">第十五篇 Bosun使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/16_assembler/">第十六篇 汇编语言使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/17_makefile/">第十七篇 Makefile使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/19_network_ratelimit/">第十九篇 Linux网络限速</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/20_mac_os_skills/">第二十篇 MacOS使用技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/21_debian_skills/">第二十一篇 Debian使用技巧</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第二章 运维工作总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweijiazhi/">第一篇 运维的价值和目标</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweizhiyeguifan/">第二篇 业务SRE的职业规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweipingtailinian/">第三篇 运维平台建设的理念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/guzhangguanli/">第四篇 故障管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/biangengguanli/">第五篇 变更管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/rongliangguanli/">第六篇 容量管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/jiagoushisiweihetezhi/">第七篇 架构师思维和特质以及中间件技术梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/cicd/">第八篇 CICD流程概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/9_changkanchangxin/">第九篇 常看常新</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/12_monitor_and_alert/">第十二篇 监控报警最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/13_classic_thinkings/">第十三篇 经典思维</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/14_performance_optimization_topic/">第十四篇 性能调优</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/15_secure_sre/">第十五篇 安全运维</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/16_yunweijiazhi/">第十六篇 公司视角下运维的价值</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/17_cdn_sre/">第十七篇 CDN运维</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第三章 Linux Net子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/1_linux_kernel_net/">第一篇 Linux数据包接收路径梳理和常用调优技能</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/2_estab_queue_monitoring/">第二篇 Linux下如何观察完整连接队列的情况</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/3_net_ipv4_tcp_syn_retries/">第三篇 理解net.ipv4.tcp_syn_retries设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/4_linux_kernel_net_v2/">第四篇 Linux网络数据包的揭秘以及常见的调优方式总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/5_conntrack/">第五篇 conntrack的常见应用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/6_tcp/">第六篇 TCP协议总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/7_udp/">第七篇 UDP协议总结以及TCP和UDP的区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/8_io_multiplexing/">第八篇 IO多路复用总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/10_linux_net/">第十篇 Linux Net子系统总结、收发包流程再次梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/11_igb/">第十一篇 igb网卡驱动梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/12_rss_rps_rfs_xps/">第十二篇 Linux网卡rss和rps和rfs和xps</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/13_linghunkaowen/">第十三篇 Linux网络子系统灵魂拷问</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第四章 Linux CPU子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/1_process_ulimit/">第一篇 进程Max open files的设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/2_pid_max/">第二篇 kernel源码中pid的最大值</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/3_interrupt_one/">第三篇 硬中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/5_soft_irq/">第四篇 软中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/4_process_thread_coroutine/">第五篇 进程、线程、协程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/6_cpu_famous_register/">第六篇 CPU中的著名寄存器梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/7_linux_signal/">第七篇 Linux信号机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/8_linux_scheduler/">第八篇 Linux进程调度</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/10_linux_context_switch/">第十篇 低视角看context switch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/11_linux_cpu_usage/">第十一篇 CPU利用率统计</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/12_linux_preemption/">第十二篇 内核抢占基础篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/13_interrupt_handler_examples/">第十三篇 中断处理程序的例子</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/14_linux_kernel_tracing/">第十四篇 理解内核追踪机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/15_task_struct/">第十五篇 task_struct结构体总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/16_init_call/">第十六篇 Linux各类initcall总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/17_coredump/">第十七篇 Linux coredump总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/18_cpu_CacheLine/">第十八篇 CPU CacheLine总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第五章 Linux IO子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/1_four_object_of_VFS/">第一篇 VFS四大对象inode、dentry、super_block、file数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/2_io_stack/">第二篇 Linux IO栈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/3_zero_copy/">第三篇 Linux 零拷贝技术总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/4_io_scheduler_layer/">第四篇 Block IO Layer(块IO层)总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/6_fss/">第六篇 各类文件系统梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/7_three_object_of_block_device/">第七篇 块设备三大对象block_device、gendisk、hd_struct数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/8_kobjet_kset_ktype/">第八篇 Linux设备模型的基石:kset/kobject/ktype</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/9_io_uring/">第九篇 io_uring研究和总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/10_device_database/">第十篇 设备数据库</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第六章 Linux Mem子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/1_linux_buddy/">第一篇 伙伴系统介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/2_slab/">第二篇 Slab层介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/3_virtual_memory/">第三篇 进程虚拟地址空间介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/4_linux_mem_theory/">第四篇 Linux内存管理基础篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/6_alloc_mem_apis/">第六篇 Linux内核内存分配API函数分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/7_physical_memory/">第七篇 关于物理内存管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/8_linux_mm_update/">第八篇 Linux内存管理升级篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/9_page_cache_and_buffer_cache/">第九篇 PageCache和BufferCache演进过程</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第七章 运维小技巧和工具汇总和积累</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/1_sync_file/">第一篇 不同主机之间的文件传输</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/2_sre_tools_python/">第二篇 运维生产力工具(python篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/3_sre_tools_website/">第三篇 运维生产力工具(网站工具)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/4_sre_tools_shell/">第四篇 运维生产力工具(shell篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/5_server_side_evolution/">第五篇 服务端进化过程梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/7_charset/">第七篇 字符集和编码</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/8_locale/">第八篇 locale设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/9_http_protocol/">第九篇 http协议</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/10_http_cookie_session_token/">第十篇 cookie和session和token总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第八章 职场通用经验</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/1_xuexixinde/">第一篇 学习心得和工作箴言</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/2_bangzhuqitatongxue/">第二篇 工作能力评价体系</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/3_yewuliuchengshuyu/">第三篇 项目管理总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/4_jishunenglimoxing/">第四篇 技术能力模型总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/5_chanpingsiwei_1/">第五篇 产品思维总结和梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/6_jixiaobaogao/">第六篇 如何写绩效报告</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/7_xiangshangguanli/">第七篇 如何向上管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/9_speaking_skills/">第九篇 沟通能力和演讲技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/10_jixiaofangtan/">第十篇 绩效访谈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/11_classic_technical_thinking/">第十一篇 经典技术思维汇总</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/12_manager_thinking/">第十二篇 管理</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第九章 编程经验和各类开源软件</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/1_suanfa/">第一篇 算法总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/2_data_structure/">第二篇 数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/3_c_lang/">第三篇 c语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/4_symbol_table/">第四篇 符号表总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/5_golang/">第五篇 go语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/6_linux_kernel_patch/">第六篇 手把手教你向Linux Kernel提交Patch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/7_python/">第七篇 python语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/8_rsyslog/">第八篇 rsyslog</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/9_falcon/">第九篇 falcon和夜莺</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/10_json_schema/">第十篇 JSON-Schema使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/11_prometheus/">第十一篇 Prometheus使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/12_grafana/">第十二篇 Grafana使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/13_mysql/">第十三篇 MySQL使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/14_mongodb/">第十四篇 MongoDB使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/15_supervisor/">第十五篇 Supervisor使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/16_redis/">第十六篇 Redis使用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/17_mongodb_2/">第十七篇 MongoDB基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/18_elk_2/">第十八篇 ELK基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/19_gitlab_ce/">第十九篇 Gitlab-CE维护</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/20_minio/">第二十篇 MinIO维护</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/21_elk_1/">第二十一篇 ELK维护</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/22_httpdns/">第二十二篇 HTTPDNS梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/23_ssl_certs/">第二十三篇 SSL证书总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/24_p4/">第二十四篇 P4服务器梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/25_fastapi/">第二十五篇 FastAPI梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/26_vue.js/">第二十六篇 Vue.js梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/27_html_basic/">第二十七篇 HTML基础梳理</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十章 容器化和Kubernetes</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../1_dockerfile_best_practice/">第一篇 dockerfile最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../2_benefits_of_containerization/">第二篇 容器化好处</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../3_docker_basic_concepts/">第三篇 容器化基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../4_kubernetes_basic_concepts/">第四篇 Kubernetes基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../6_production_kubernetes_best_practice/">第六篇 生产环境Kubernetes部署最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../7_production_kerbernetes_yaml/">第七篇 生产环境Kubernetes YAML模版</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">第八篇 Kubernetes网络插件之Calico</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#calico-pod">一 calico 基本原理之本机Pod之间通信</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_2">抓包验证</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_3">总结</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#calico-vxlan">二 calico 基本原理之VXLAN</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#calico-ipip">三 calico 基本原理之IPIP</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#calico-bgp">四 calico 基本原理之BGP</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#caclio-01-running">五 caclio 0/1 Running 问题从解决到根因分析</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#169254">六 关于169.254网段</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">七 容器网络原理</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-linux">1 Linux 虚拟网络技术</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-linux-veth-pair">2 Linux veth pair</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-bridge">3 Bridge</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#31-namespace-root-namespace">3.1 子 namespace 访问 root namespace</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#32-namespace">3.2 子 namespace 访问外网</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#33">3.3 端口映射</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4">4 容器网络模式</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#41-host">4.1 Host</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#42-none">4.2 None</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#43-bridge">4.3 Bridge</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#44-container">4.4 Container</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5">5 总结</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../9_cloudnative_monitor/">第九篇 云原生监控</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../10_event/">第十篇 彻底搞懂Kubernetes Event</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../11_best_practices/">第十一篇 Kubernetes最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../12_cloud_network/">第十二篇 云网络</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../13_containerd/">第十三篇 Containerd</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../14_k8s_and_gpu/">第十四篇 基于K8S管理GPU集群</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../15_public_cloud_use/">第十五篇 公有云最佳实践总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../16_podman/">第十六篇 Podman总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十一章 SRE稳定性建设从理论到实践</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/1_theory/">第一篇 稳定性概论</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/10_high_avaliable/">第二篇 高可用原则总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/2_slo_process/">第三篇 SLO实施流程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/3_stress/">第四篇 压测经验总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/11_stability/">第五篇 稳定性理论总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十二章 商业化知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_12/1_shifouzhide/">第一篇 如何判断一件事情值不值得做</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十三章 芯片知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_13/1_about_riscv/">第一篇 RISC-V 简介</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_13/2_danpianji/">第二篇 单片机简介</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十四章 Linux驱动方向总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/1_demo_of_led_driver/">第一篇 驱动程序的Hello World</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/2_qianrushidev/">第二篇 嵌入式开发基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/3_linux_kernel_api_list/">第三篇 Linux内核API汇总和各类风格总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/4_zifushebeiqudongyuanli/">第四篇 字符设备驱动实现原理和物理内存地址空间和IO端口空间</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/5_device_tree/">第五篇 platform总线模型和设备树</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/6_device_driver_sop/">第六篇 从阅读硬件手册开始设备驱动程序编写</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/7_linux_kernel_clipping/">第七篇 Linux移植</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/8_linux_driver_framework/">第八篇 Linux驱动框架和SoC驱动框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/9_linux_device_class/">第九篇 Linux设备分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/10_u_boot/">第十篇 u-boot梳理和总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/11_linux_reset_subsystem_and_framework/">第十一篇 Linux Reset子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/12_pinctl_and_gpio/">第十二篇 Linux pinctl和gpio子系统及其框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/13_embedded_development_direction/">第十三篇 嵌入式开发方向和分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/14_linux_kernel_trimming/">第十四篇 Linux内核裁剪总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_14/15_imx6ull/">第十五篇 IMX6UL实验记录</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十五章 AI+嵌入式结合方向汇总</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_15/1_basic_of_ai/">第一篇 AI入门</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_15/2_nvidia_gpu/">第二篇 英伟达GPU产品分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_15/3_basic_of_mcp/">第三篇 MCP入门</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十六章 网络安全方向</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_16/1_network_attack/">第一篇 认识各种网络攻击</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Lott's Blog</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>第十章 容器化和Kubernetes &raquo;</li>
      <li>第八篇 Kubernetes网络插件之Calico</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">概述</h1>
<ul>
<li>本篇总结 Calico 的原理到实践</li>
<li>Kubernetes 作为分布式调度平台本身不提供集群网络方案，只提出 CNI ( container network interface ) 标准，任何个人开发者或者网络厂商按照改标准实现，即可实现 Kubernetes 网络通信。Calico[1] 是 Kubernetes 生态系统中一种流行的网络选择，Calico 以其性能、灵活性而闻名。Calico 自身支持多种网络模式，例如 IPIP、VXLAN 等 Overlay 模式，还有 BGP 三层路由模式，都有成熟的实现，可根据环境和需求选择任一即可。</li>
</ul>
<h2 id="calico-pod">一 calico 基本原理之<a href="https://mp.weixin.qq.com/s?__biz=MzkyNDMyNjAyMg==&amp;mid=2247484577&amp;idx=1&amp;sn=446c2f6f65cedd98de2fbe36c70d6da1&amp;scene=21#wechat_redirect">本机Pod之间通信</a></h2>
<ul>
<li>pod-a、pod-b 都运行在 node-172-31-186-250，其中 pod-a ip 为 100.79.126.203，pod-b ip 为 100.79.126.201</li>
</ul>
<pre><code>$ kubectl get pods -o wide
NAME                     READY   STATUS    RESTARTS   AGE     IP               NODE                  NOMINATED NODE   READINESS GATES
pod-a-68c8f9cccd-sgtvg   1/1     Running   0          7m8s    100.79.126.203   node-172-31-186-250   &lt;none&gt;           &lt;none&gt;
pod-b-68c8f9cccd-gr4hw   1/1     Running   0          6m53s   100.79.126.201   node-172-31-186-250   &lt;none&gt; 
</code></pre>
<ul>
<li>进入 pod-a 容器内去 ping pod-b，可以 ping 通，网络没有问题</li>
</ul>
<pre><code>/ # ping 100.79.126.201
PING 100.79.126.201 (100.79.126.201): 56 data bytes
64 bytes from 100.79.126.201: seq=0 ttl=63 time=0.103 ms

</code></pre>
<ul>
<li>再查看 pod-a 内的路由，这有这两条路由，同样查看其他 pod，发现都是只有这两条路由。</li>
</ul>
<pre><code>/ # route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         169.254.1.1     0.0.0.0         UG    0      0        0 eth0
169.254.1.1     0.0.0.0         255.255.255.255 UH    0      0        0 eth0
</code></pre>
<ul>
<li>
<ul>
<li>根据上述路由表，在 pod 内所有流量都会匹配第一条默认路由，从 eth0 网卡到达网关 169.254.1.1，但是主机上并没有任何一张网卡 ip 是 169.254.1.1。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在网络通信时，涉及到三层网络就会先匹配路由，从路由表查到网关后，首先会通过 ARP 获取网关的 MAC 地址，将报文中目标 MAC 地址改为网关的 MAC，但是网关的 IP 地址不会封装到网络任一报文中。也就是说这个网关 IP 地址是什么无所谓，只要能找到对应 MAC 地址即可，也就是有网卡能响应 ARP 请求即可。</p>
</blockquote>
<ul>
<li>在 pod-a 查看 pod 内 ARP 缓存：</li>
</ul>
<pre><code>/ # ip neigh
169.254.1.1 dev eth0 lladdr ee:ee:ee:ee:ee:ee used 0/0/0 probes 1 STALE

</code></pre>
<ul>
<li>可以发现网关 169.254.1.1 的 MAC 地址是 ee:ee:ee:ee:ee:ee，那么这个 MAC 地址是哪个网关的呢？</li>
</ul>
<p>无论是容器网络还是 K8S 网络，都是基于 Linux veth-pair 技术实现 Network namespace 间通信，所以在 pod-a 和主机节点上使用一对 veth-pair 连接。</p>
<p>在 pod 内 eth0@xxxx 是 veth-pair 的一端，pod-a 内的网卡名是 eth0@if331</p>
<pre><code>/ # ip addr show dev eth0
3: eth0@if331: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1450 qdisc noqueue state UP qlen 1000
    link/ether 5a:8a:10:57:e2:03 brd ff:ff:ff:ff:ff:ff
    inet 100.79.126.203/32 scope global eth0
       valid_lft forever preferred_lft forever

</code></pre>
<p>另一端则在物理主机节点上，在物理节点上有很多个以 calicoxxxxx@xx 命令的网卡，这些都是每个 pod veth-pair 的一端。每 pair 的接口均有相同的 inteface index，pod-a 是 331，所以直接在节点上查看：</p>
<pre><code>$ ip link show | egrep '^331:' -A 1
331: cali14e7d81007d@if3:  mtu 1450 qdisc noqueue state UP mode DEFAULT group default qlen 1000
    link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 32

</code></pre>
<p>即 cali14e7d81007d 和 pod-a 中的 eth0 是一个 veth-pair，也就说明 pod-a eth0 与 主机的 cali14e7d81007d 在一个广播域，所以 pod-a 向网关 169.254.1.1 发起的 ARP 请求会被 cali14e7d81007d 接收，但是 cali14e7d81007d 上也没有配置 169.254.1.1 地址，为什么可以回复 ARP 请求？这里涉及到一个 Linux proxy_arp 知识：</p>
<blockquote>
<p>将 <code>/proc/sys/net/ipv4/conf/&lt;interface-dev&gt;/proxy_arp</code> 置为1，该网卡就会看起来像一个网关，会响应所有的ARP请求，并将自己的MAC地址告诉客户端。</p>
</blockquote>
<p>下面查看节点上 cali14e7d81007d 的 proxy_arp 是否开启</p>
<pre><code>$ cat /proc/sys/net/ipv4/conf/cali14e7d81007d/proxy_arp
1

</code></pre>
<p>确实开启了，所以说当 cali14e7d81007d 网卡收到 pod 内发出的 ARP 请求，就会回复 ARP，将自己的 MAC 地址返回给 pod-a。</p>
<p>当 pod-a 拿到网关 MAC 地址后，进行封包，报文发送到网关，也就是主机上的 cali14e7d81007d 。</p>
<p>报文到达主机后，即匹配主机路由，下面查看主机路由表：</p>
<pre><code>
$ route -n 
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
100.79.126.201  0.0.0.0         255.255.255.255 UH        0 0          0 calieabe7761b00

</code></pre>
<p>可以发现发往 100.79.126.201( pod-b ip ) 的报文直接通过 calieabe7761b00 网卡出去，calieabe7761b00 网卡也就是 pod-b veth-pair 在主机上的一端，</p>
<p>进而报文通过 pod-b veth-pair 进入 pod-b 内。</p>
<p>以上就是同节点 pod 间通信的全过程，下面通过抓包来分析验证。</p>
<p>以下是同节点 Pod 间通信的报文流转图：</p>
<p><img alt="png" src="../../img/DA88BF28-563B-439E-8DAA-F9B1F2A8494C.jpg" /></p>
<h3 id="_2">抓包验证</h3>
<p>在 pod-a ping pod-b，同时主机 pod-a veth-pair 对端网卡即 cali14e7d81007d 抓包</p>
<p>在抓包之前，先通过 <code>ip neigh flush dev eth0</code> 命令清理 pod-a 的 arp 缓存，否则可能抓不到 ARP 报文</p>
<pre><code>
$ tcpdump -nn -i cali14e7d81007d -e
dropped privs to tcpdump
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on cali14e7d81007d, link-type EN10MB (Ethernet), capture size 262144 bytes
# pod-a 发起广播, 获取网关 MAC 地址
16:22:59.584235 aa:64:43:69:fd:8d &gt; ff:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Request who-has 169.254.1.1 tell 100.79.126.235, length 28
# pod-a 对端网卡回复 ARP 请求
16:22:59.584286 ee:ee:ee:ee:ee:ee &gt; aa:64:43:69:fd:8d, ethertype ARP (0x0806), length 42: Reply 169.254.1.1 is-at ee:ee:ee:ee:ee:ee, length 28
# 使用对端网卡的 MAC 地址进行报文封装
16:22:59.584290 aa:64:43:69:fd:8d &gt; ee:ee:ee:ee:ee:ee, ethertype IPv4 (0x0800), length 98: 100.79.126.235 &gt; 100.79.126.201: ICMP echo request, id 15, seq 0, length 64    
16:22:59.584372 ee:ee:ee:ee:ee:ee &gt; aa:64:43:69:fd:8d, ethertype IPv4 (0x0800), length 98: 100.79.126.201 &gt; 100.79.126.235: ICMP echo reply, id 15, seq 0, length 64      
16:23:00.584456 aa:64:43:69:fd:8d &gt; ee:ee:ee:ee:ee:ee, ethertype IPv4 (0x0800), length 98: 100.79.126.235 &gt; 100.79.126.201: ICMP echo request, id 15, seq 1, length 64
16:23:00.584526 ee:ee:ee:ee:ee:ee &gt; aa:64:43:69:fd:8d, ethertype IPv4 (0x0800), length 98: 100.79.126.201 &gt; 100.79.126.235: ICMP echo reply, id 15, seq 1, length 64   

</code></pre>
<p>可以发现 pod-a 先发起 ARP 请求，获取网关 169.254.1.1 的 MAC 地址，由对端网卡 cali14e7d81007d 回复其 MAC 地址。</p>
<h3 id="_3">总结</h3>
<ul>
<li>同节点的 Pod 之间通信实际上还是利用的 Linux veth-pair 技术以及网络路由，并没有使用到 Calico 的核心网络模式，例如 IPIP、VXLAN、BGP。</li>
</ul>
<h2 id="calico-vxlan">二 calico 基本原理之VXLAN</h2>
<ul>
<li>
<p>VXLAN（Virtual eXtensible Local Area Network，虚拟扩展局域网）是一种网络虚拟化技术，旨在解决大型云数据中心和多租户环境中传统 VLAN（虚拟局域网）技术的局限性。VXLAN 通过在 UDP（User Datagram Protocol）之上封装第二层以太网帧，实现在第三层（IP）网络上的二层网络扩展，从而允许创建多达 1600 万个隔离的虚拟网络，远超 VLAN 的 4096 个网络限制。VXLAN 报文格式如下：</p>
</li>
<li>
<ul>
<li>VXLAN 标识头：VXLAN header 这里只需要关注一个字段，那就是VNI，前文简单提到过, 在目标 node 上的 flannel.1 上会对这个VNI字段进行 check，看是否与自己的 VNI 一致，一致的话才会进行处理。</li>
</ul>
</li>
<li>
<ul>
<li>UDP 头：在外层新增 UDP 头，默认目的端口号是 4789</li>
</ul>
</li>
<li>
<ul>
<li>IP 头：在外层新增 IP 头，源地址是当前节点物理网卡 IP，目的地址是对端节点物理网卡 IP</li>
</ul>
</li>
<li>
<ul>
<li>MAC 头：源 MAC 是当前节点物理网卡 MAC 地址，目的 MAC 是对端节点物理网卡 MAC 地址</li>
</ul>
</li>
</ul>
<p><img alt="png" src="../../img/10B1BC05-D6AB-410C-BF9F-0BCB0C0C8878.jpg" /></p>
<h2 id="calico-ipip">三 calico 基本原理之IPIP</h2>
<h2 id="calico-bgp">四 calico 基本原理之BGP</h2>
<h2 id="caclio-01-running">五 caclio 0/1 Running 问题从解决到根因分析</h2>
<h2 id="169254">六 关于169.254网段</h2>
<ul>
<li>
<p><strong>169.254.x.x</strong> 是一个特殊的 IPv4 地址段，属于 APIPA（Automatic Private IP Addressing，自动专用IP寻址） 范围，主要用于以下情况：</p>
</li>
<li>
<ul>
<li>1 当设备无法通过DHCP获取IP时</li>
</ul>
</li>
</ul>
<p>如果计算机或设备配置为自动获取IP（DHCP），但无法从DHCP服务器（如路由器）获得有效IP地址，系统会自动分配一个 169.254.x.x（子网掩码 255.255.0.0） 的地址。</p>
<p>这表明设备没有正确连接到网络或DHCP服务不可用。</p>
<ul>
<li>
<ul>
<li>2 链路本地地址（Link-Local Address）</li>
</ul>
</li>
</ul>
<p>这个网段（169.254.0.0/16）是预留给本地链路通信的，类似于IPv6的 fe80::/10。</p>
<ul>
<li>
<p>它仅用于同一局域网内的设备间通信，<strong>无法被路由器转发到外网。</strong></p>
</li>
<li>
<p>对比其他私有IP段</p>
</li>
<li>
<ul>
<li><code>10.0.0.0/8</code>、<code>172.16.0.0/12</code>、<code>192.168.0.0/16</code> 是常规内网IP，需手动或DHCP分配。</li>
</ul>
</li>
<li>
<ul>
<li><code>169.254.0.0/16</code> 是系统自动分配的“应急地址”，表明网络配置异常。</li>
</ul>
</li>
</ul>
<p>也就是你的主机可以自己分配一个<code>169.254.0.0/16</code>网段内的IP，然后把网关设置为<code>169.254.1.1</code>, 此时只要主机和网关之间满足二层可通信即可，主机就可以把自己的包发到更加外围的网段</p>
<h2 id="_4">七 <a href="https://mp.weixin.qq.com/s/tjLsr_8eFnwbqy9_G2H7ow">容器网络原理</a></h2>
<h3 id="1-linux">1 Linux 虚拟网络技术</h3>
<p>一般网络设备包括，交换机，路由器，网桥等，这些网络设备会存在多个网卡或者端口，那么 Linux 不仅仅可以作为网络设备，同时还可以实现虚拟网络设备，例如：网桥，虚拟网卡对等，那么 <code>Network Namespace</code> 就是利用 Linux 虚拟网络技术、路由、iptables 等技术来实现的。下面看看常用的 <strong>veth pair</strong> 和 <strong>bridge</strong>。</p>
<h3 id="2-linux-veth-pair">2 Linux veth pair</h3>
<ul>
<li>
<p><strong>veth pair</strong> 是成对出现的一种虚拟网络设备接口，一端连着网络协议栈，一端彼此相连。<strong>veth pair 总是成对出现的</strong>，从一端进入的数据包将会在另一端出现。我们可以把 <strong>veth pair</strong> 看成一条网线两端连接的两张以太网卡。只要将 <strong>veth pair</strong> 每一段分别接入不同的 <code>Namespace</code>，那么这两个 <code>Namespace</code> 就可以实现互通了</p>
</li>
<li>
<p>Linux 即使在同一个主机上创建的两个 <code>Network Namespace</code>，相互之间缺省也是不能进行网络通信的。</p>
</li>
<li>
<p><img alt="png" src="../../img/7B70A56B-9B11-41E9-98DD-A1E9FE2B4848.jpg" /></p>
</li>
<li>
<p>下面通过示例将两个 <code>Namespace</code> 通过 <strong>veth pair</strong> 连接起来，并验证连通性。</p>
</li>
<li>
<p>创建两个 <code>namespace，ns1、ns2</code></p>
</li>
</ul>
<pre><code>$ ip netns add ns1
$ ip netns add ns2
</code></pre>
<p>创建一个 veth pair</p>
<pre><code>$ ip link add veth-ns1 type veth peer name veth-ns2
</code></pre>
<p>将 veth pair 一端接入放入 ns1，另一端接入 ns2，这样就相当于采用网线将两个 Network Namespace 连接起来了。</p>
<pre><code>$ ip link set veth-ns1 netns ns1
$ ip link set veth-ns2 netns ns2
</code></pre>
<p>为两个网卡分别设置 IP 地址，这两个网卡的地址位于同一个子网 192.168.1.0/24 中。</p>
<pre><code>$ ip -n ns1 addr add 192.168.1.1/24 dev veth-ns1
$ ip -n ns2 addr add 192.168.1.2/24 dev veth-ns2

</code></pre>
<p>使用 ip link 命令设置两张虚拟网卡状态为 up。</p>
<pre><code>$ ip -n ns1 link set veth-ns1 up
$ ip -n ns2 link set veth-ns2 up
</code></pre>
<p>从 ns1 ping ns2 的 IP，测试连通性</p>
<pre><code>$ ip netns exec ns1 ping 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.142 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.021 ms

</code></pre>
<p>上面创建了一对 veth pair 连接着两个 namespace，可以分别进入 namespace 查看到对应网卡信息</p>
<pre><code>$ ip netns exec ns1 ifconfig
veth-ns1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.1.1  netmask 255.255.255.0  broadcast 0.0.0.0
        inet6 fe80::e415:f8ff:fe53:bbb3  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether e6:15:f8:53:bb:b3  txqueuelen 1000  (Ethernet)
        RX packets 45  bytes 3693 (3.6 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 54  bytes 4642 (4.5 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

$ ip netns exec ns2 ifconfig
veth-ns2: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.1.2  netmask 255.255.255.0  broadcast 0.0.0.0
        inet6 fe80::e415:f8ff:fe53:bbb3  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether e6:15:f8:53:bb:b3  txqueuelen 1000  (Ethernet)
        RX packets 45  bytes 3693 (3.6 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 54  bytes 4642 (4.5 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
<h3 id="3-bridge">3 Bridge</h3>
<p>veth pair 实现了两个网络之间的连通，如果我们需要将 3 个或者多个 namespace 接入同一个二层网络时，就不能只使用 veth pair 了。在物理网络中，如果需要连接多个主机，我们会使用网桥，或者又称为交换机。Linux 也提供了网桥的虚拟实现。</p>
<p><img alt="png" src="../../img/8DE2CAEE-4902-438B-B749-052B2438E010.jpg" /></p>
<p>那么下面通过示例演示通过 Bridge 来连通三个 namespace。</p>
<p>首先创建三个 namespace</p>
<pre><code>$ ip netns add ns1
$ ip netns add ns2
$ ip netns add ns3
</code></pre>
<p>创建 Linux Bridge</p>
<pre><code>$ brctl addbr virtual-bridge
</code></pre>
<p>这里需要创建三对 veth pair，因为每一对的 veth pair 需要与 bridge 连接。将每对 veth pair 的一端接入对应 namespace，另一端接入 bridge</p>
<pre><code># 创建 veth pair
$ ip link add veth-ns1 type veth peer name veth-ns1-br
# 将 veth pair 一端接入 ns1
$ ip link set veth-ns1 netns ns1
# 将 veth pair 另一端接入 bridge
$ brctl addif virtual-bridge veth-ns1-br

$ ip link add veth-ns2 type veth peer name veth-ns2-br
$ ip link set veth-ns2 netns ns2
$ brctl addif virtual-bridge veth-ns2-br

$ ip link add veth-ns3 type veth peer name veth-ns3-br
$ ip link set veth-ns3 netns ns3
$ brctl addif virtual-bridge veth-ns3-br
</code></pre>
<p>为三个 namespace 中的虚拟网卡设置 IP 地址，这些 IP 地址位于同一个子网 192 168.1.0/24 中。</p>
<pre><code>$ ip -n ns1 addr add local 192.168.1.1/24 dev veth-ns1
$ ip -n ns2 addr add local 192.168.1.2/24 dev veth-ns2
$ ip -n ns3 addr add local 192.168.1.3/24 dev veth-ns3

</code></pre>
<p>将 bridge 和 veth pair 启动</p>
<pre><code>$ ip link set virtual-bridge up

$ ip link set veth-ns1-br up
$ ip link set veth-ns2-br up
$ ip link set veth-ns3-br up

$ ip -n ns1 link set veth-ns1 up
$ ip -n ns2 link set veth-ns2 up
$ ip -n ns3 link set veth-ns3 up
</code></pre>
<p>测试三个 namespace 之间的连通性</p>
<pre><code>$ ip netns exec ns1 ping 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.165 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.131 ms

$ ip netns exec ns1 ping 192.168.1.3
PING 192.168.1.3 (192.168.1.3) 56(84) bytes of data.
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.345 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.163 ms

</code></pre>
<p>这里的 bridge 只扮演了二层设备的角色，就可以实现同一子网下的两个 namespace 的通信。</p>
<p>如果 namespace 里需要访问宿主机或者访问外网，那么 bridge 作为二层设备就无法实现了，因为数据包只能到达 bridge。</p>
<h4 id="31-namespace-root-namespace">3.1 子 namespace 访问 root namespace</h4>
<p>要想子 namespace 访问 root namespace，单纯的二层通信无法实现。</p>
<p>Linux Bridge 即可以扮演二层交换机，也可作为三层交换机或者路由器使用，我们只需将 bridge 设置 IP，并作为子 namespace 的默认网关，这样数据包就可以通过 bridge 来到 root namespace。</p>
<pre><code>
如果 Linux 需要扮演三层设备，必须开启 IP 转发

sysctl -w net.ipv4.ip_forward=1 或者 echo 1 &gt; /proc/sys/net/ipv4/ip_forward

这种设置只是暂时的，它的效果会随着计算机的重启而失效。
</code></pre>
<p>首先创建子 namespace 和 bridge</p>
<pre><code>$ ip netns add ns1
$ ip netns add ns2
$ brctl addbr br0
</code></pre>
<p>通过 veth pair 将 ns1 和 ns2 连接到 bridge 上。</p>
<pre><code>$ ip link add veth-ns1 type veth peer name veth-ns1-br
$ ip link set veth-ns1 netns ns1
$ brctl addif br0 veth-ns1-br

$ ip link add veth-ns2 type veth peer name veth-ns2-br
$ ip link set veth-ns2 netns ns2
$ brctl addif br0 veth-ns2-br
</code></pre>
<p>为 ns1，ns2 设置 IP 地址。</p>
<pre><code>$ ip -n ns1 addr add local 192.168.1.2/24 dev veth-ns1
$ ip -n ns2 addr add local 192.168.1.3/24 dev veth-ns2

</code></pre>
<p>启动 bridge 和 veth pair</p>
<pre><code>$ ip link set br0 up
$ ip link set veth-ns1-br up
$ ip link set veth-ns2-br up
$ ip -n ns1 link set veth-ns1 up
$ ip -n ns2 link set veth-ns2 up
</code></pre>
<p>从 ns1 ping root namespace，发现网络不可达。</p>
<pre><code># 172.30.95.74 是宿主机网卡
$ ip netns exec ns1 ping 172.30.95.74
connect: Network is unreachable

</code></pre>
<p>需要先给 bridge 设置 IP，这里需要将 bridge 设置为 ns1、ns2 的默认网关</p>
<pre><code>$ ip addr add local 192.168.1.1/24 dev br0
$ ip link set br0 up

$ ip netns exec ns1 ip route add default via 192.168.1.1
$ ip netns exec ns2 ip route add default via 192.168.1.1

</code></pre>
<p>可以查看到宿主机上 br0 网卡上配置了 IP</p>
<pre><code>$ ifconfig br0
br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.1.1  netmask 255.255.255.0  broadcast 0.0.0.0
        inet6 fe80::d6:2dff:fec5:a767  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 02:d6:2d:c5:a7:67  txqueuelen 1000  (Ethernet)
        RX packets 15  bytes 1032 (1.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8  bytes 656 (656.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</code></pre>
<p>这次从 ns1 、 ns2 ping root namespace，发现网络可达。</p>
<pre><code>$ ip netns exec ns1 ping 172.30.95.74
PING 172.30.95.74 (172.30.95.74) 56(84) bytes of data.
64 bytes from 172.30.95.74: icmp_seq=1 ttl=64 time=0.097 ms
64 bytes from 172.30.95.74: icmp_seq=2 ttl=64 time=0.061 ms

$ ip netns exec ns2 ping 172.30.95.74
PING 172.30.95.74 (172.30.95.74) 56(84) bytes of data.
64 bytes from 172.30.95.74: icmp_seq=1 ttl=64 time=0.124 ms
64 bytes from 172.30.95.74: icmp_seq=2 ttl=64 time=0.062 ms
</code></pre>
<h4 id="32-namespace">3.2 子 namespace 访问外网</h4>
<p>如果想要子 namespace 能够访问外网，那么还需要将设置一条 iptables 规则。</p>
<p>因为不设置规则的话，从子 namespace 发送数据包可以出去，但是回包会有问题，因为回包的时候，目的 IP 是子 namespace IP，但是每个节点的路有点并没有到子 namespace IP 的路由，所以就需要在 namespace 里设置一条 SNAT Iptables 规则，发送数据包到 bridge 时，将源地址改为宿主机 IP，这样回包时就无需知道 namespace 下的 IP 了。</p>
<pre><code>$ iptables -t nat -A POSTROUTING -s 192.168.1.0/24 ! -o br0 -j MASQUERADE

</code></pre>
<p>这样子 namespace 下就可以访问外网了</p>
<p>下图展示 IP 数据包经过 SNAT 规则后，报文的源 IP 发生了改变</p>
<ul>
<li><img alt="png" src="../../img/3ED87C16-5597-42DE-A98B-14EB1AF65914.jpg" /></li>
</ul>
<h4 id="33">3.3 端口映射</h4>
<p>如果想要将子 namespace 里的端口发布出去给外部访问，就需要使用 Linux DNAT 技术。</p>
<p>比如在 ns1 启动一个 8001 端口的服务，想要暴露给外部访问</p>
<pre><code>$ ip netns exec ns1 python3 -m http.server --bind 192.168.1.2 8001

</code></pre>
<p>通过 iptables 设置 DNAT 规则发布端口，DNAT 规则作用就是将 IP 包的目的地址和端口进行修改再转发。</p>
<pre><code># 为来自外部的流量做 DNAT
$ iptables -t nat -A PREROUTING -d 172.30.95.72 -p tcp -m tcp --dport 8001 -j DNAT --to-destination 192.168.1.2:8001

# 为来自 host 自己的流量做 DNAT（因为本地流量不会经过 PREROUTING chain）
$ iptables -t nat -A OUTPUT -d  172.30.95.72 -p tcp -m tcp --dport 8001 -j DNAT --to-destination 192.168.1.2:8001

</code></pre>
<p>可以查看到对应 iptables 规则</p>
<p>下图展示 IP 数据包经过 DNAT 规则后，报文的目的 IP 和目的端口都进行了变化</p>
<p><img alt="png" src="../../img/32863915-9D32-4EDF-8C29-B947ED725FA9.jpg" /></p>
<p>在平时使用容器网络时，无非就是以上几种网络场景：<strong>宿主机上容器间访问</strong>，<strong>容器内访问外网</strong>，<strong>外部访问容器内的服务</strong>。</p>
<p>下面就看看容器网络是如何实现的。</p>
<h3 id="4">4 容器网络模式</h3>
<p>Docker 可以为容器提供四种网络模式：</p>
<ul>
<li>
<p>Host：该网络模式使得容器与宿主机属于同一个网络 namespace，这样容器网络和宿主机一样，使用 --net=host 指定</p>
</li>
<li>
<p>Bridge：该网络模式是 Docker 默认的网络模式，类似于上文说的例子，使用 --net=bridge 指定</p>
</li>
<li>
<p>Container：复用其他容器的网络模式，使用 --net=container:NAME_or_ID 指定</p>
</li>
<li>
<p>None：表示容器没有网络，即容器没有 IP、路由等网络协议栈，使用 --net=none 指定</p>
</li>
</ul>
<h4 id="41-host">4.1 Host</h4>
<p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p>
<p>这里启动一个 host 模式的容器，会发现容器的网络协议栈与宿主机一样。</p>
<pre><code>$ docker run -it --net host busybox:latest ifconfig
</code></pre>
<h4 id="42-none">4.2 None</h4>
<p>使用 none 模式，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker 容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p>
<pre><code>$ docker run -it --net none artifacts.iflytek.com/docker-private/cloudnative/busybox:1.35 ifconfig
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</code></pre>
<h4 id="43-bridge">4.3 Bridge</h4>
<p>如果不指定网络模式的话，该模式是 Docker 创建容器时默认网络模式。原理图如下：</p>
<ul>
<li><img alt="png" src="../../img/A804CE1D-D540-4643-BD79-D1D414E8301A.jpg" /></li>
</ul>
<p>当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥，并且分配一个 IP，该 IP 就是后面容器的默认网关。</p>
<pre><code>$ ifconfig docker0
docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fe80::42:a8ff:fe2a:210  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 02:42:a8:2a:02:10  txqueuelen 0  (Ethernet)
        RX packets 10274607  bytes 1726083694 (1.6 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8862553  bytes 5870677425 (5.4 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
<p>创建 Bridge 网络模式的容器，可以发现容器属于单独 Network Namespace，且 Docker 创建一对 veth pair(eth0@if38：vethf240dfc@if37) ，一端接入容器内，一端接入 Docker0 网桥上。</p>
<pre><code>$ docker run -it --net bridge busybox:latest sh
/ # ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
37: eth0@if38: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe11:2/64 scope link
       valid_lft forever preferred_lft forever

/ # ip link show eth0
35: eth0@if36: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff

# 宿主机上查看
$ ip addr | grep 38
38: vethf240dfc@if37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default

</code></pre>
<p>同时查看容器内的路由表，发现容器的默认网关指向 Docker0</p>
<pre><code>/ # route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0

</code></pre>
<p>再创建一个容器，然后访问另一个容器，发现可以互通</p>
<pre><code>$ docker run -it --net bridge busybox:latest sh
/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03
          inet addr:172.17.0.3  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:acff:fe11:3/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:16 errors:0 dropped:0 overruns:0 frame:0
          TX packets:16 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:1216 (1.1 KiB)  TX bytes:1216 (1.1 KiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
/ # ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.108 ms
64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.119 ms
</code></pre>
<p>虽然两个容器属于单独 Network Namespace，但是都通过 veth pair 接入了 docker0 网桥，且在同一个子网下面，所以可以二层互通。</p>
<p>在宿主机上查看 docker0 网桥上挂的网卡，发现两张网卡就是两个容器的一端。</p>
<pre><code>$ brctl show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.02428f5df66f       no              veth2a72e0f
                                                        vethf240dfc

$ ifconfig | grep veth
veth2a72e0f: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
vethf240dfc: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500

</code></pre>
<p>现在在容器内访问外网，同样也是正常的，因为 Docker 在宿主机上创建了对应的 SNAT 规则。</p>
<pre><code>/ # ping www.baidu.com
PING www.baidu.com (153.3.238.102): 56 data bytes
64 bytes from 153.3.238.102: seq=0 ttl=49 time=8.843 ms
64 bytes from 153.3.238.102: seq=1 ttl=49 time=8.422 ms

# 宿主上查看 iptables SNAT 规则
$ iptables -t nat -nL POSTROUTING
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0


</code></pre>
<p>现在创建一个暴露端口的容器供外部访问，将容器的 80 端口映射到宿主机的 8080 端口。</p>
<p>$ docker run -d --net bridge -p 8080:80 nginx:latest</p>
<pre><code>$ curl http://172.30.95.74:8080
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>测试发现访问正常，因为 Docker 也会在宿主机上创建对应的 DNAT 规则。</p>
<ul>
<li><img alt="png" src="../../img/7DC5A28B-FB64-4EDC-9660-7BABA45D8650.jpg" /></li>
</ul>
<p>这里的 DNAT 规则发现与上面举例的不大一样，这里解释一下</p>
<p>上面说到 namespace 发布端口需要在 PREROUTING、OUTPUT 这两条链创建 DNAT，这里同样也是在这两条链创建了 DNAT 规则，只不过跳到了 DOCKER 自定义链了，然后这个 Chain DOCKER 设置了具体的 DNAT 规则。</p>
<p>经过以上说明，发现 Bridge 模式使用的技术其实就是上面说到 Linux 虚拟网络技术。</p>
<h4 id="44-container">4.4 Container</h4>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。原理图如下：</p>
<ul>
<li><img alt="png" src="../../img/EA3BCF40-0DF3-4267-AE39-7DF9DB5B9923.jpg" /></li>
</ul>
<p>这里先创建一个容器，指定 bridge 网络模式。</p>
<pre><code>docker run -it --net bridge busybox:latest sh
/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03
          inet addr:172.17.0.3  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:acff:fe11:3/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:6 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:516 (516.0 B)  TX bytes:426 (426.0 B)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</code></pre>
<p>然后创建另外一个容器，并且设置与上面容器网络模式共享，发现该容器的网络协议栈与上一个容器的一致。</p>
<pre><code>docker run -it --net container:8d5aedb8ed81 busybox:latest sh
/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03
          inet addr:172.17.0.3  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:acff:fe11:3/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:656 (656.0 B)  TX bytes:656 (656.0 B)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</code></pre>
<h3 id="5">5 总结</h3>
<ul>
<li>
<p>本篇文章首先讲解了 Linux 虚拟网络相关技术：</p>
</li>
<li>
<ul>
<li>veth pair：虚拟网卡对</li>
</ul>
</li>
<li>
<ul>
<li>bridge：虚拟网桥，Linux 虚拟网桥不仅可以作为二层设备也可以作为三层设备</li>
</ul>
</li>
<li>
<p>进而通过实例讲解实现了在 Network Namespace 不同的网络场景：</p>
</li>
<li>
<ul>
<li>Network Namespace 间的通信</li>
</ul>
</li>
<li>
<ul>
<li>子 Network Namespace 与 root Namespace 间通信</li>
</ul>
</li>
<li>
<ul>
<li>子 Network Namespace 访问外网</li>
</ul>
</li>
<li>
<ul>
<li>Network Namespace 发布服务端口供外部访问</li>
</ul>
</li>
<li>
<p>了解了 Linux 虚拟网络技术，然后通过对容器网络的介绍，基本可以了解文章开头提出 “容器网络需要解决什么问题”。</p>
</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../7_production_kerbernetes_yaml/" class="btn btn-neutral float-left" title="第七篇 生产环境Kubernetes YAML模版"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../9_cloudnative_monitor/" class="btn btn-neutral float-right" title="第九篇 云原生监控">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../7_production_kerbernetes_yaml/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../9_cloudnative_monitor/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
