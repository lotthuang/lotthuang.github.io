<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>第六篇 从阅读硬件手册开始设备驱动程序编写 - Lott's Blog</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u7b2c\u516d\u7bc7 \u4ece\u9605\u8bfb\u786c\u4ef6\u624b\u518c\u5f00\u59cb\u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f\u7f16\u5199";
        var mkdocs_page_input_path = "chapter_14/6_device_driver_sop.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Lott's Blog
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">首页</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">第一章 各种杂项基础</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/1_make_blog/">第一篇 利用Github Pages和mkdocs搭建个人博客</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/2_nginx_loadbalancing_strategy/">第二篇 Nginx的均衡策略</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/3_linux_kernel_basic/">第三篇 Linux内核基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/4_linux_kernel_mm_basic/">第四篇 Linux内核空间内存概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_1/5_how_kernel_call_bios/">第五篇 Linux内核调用BIOS案例</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第二章 运维工作总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweijiazhi/">第一篇 运维的价值和目标</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweizhiyeguifan/">第二篇 业务SRE的职业规范</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/yunweipingtailinian/">第三篇 运维平台建设的理念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/guzhangguanli/">第四篇 故障管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/biangengguanli/">第五篇 变更管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/rongliangguanli/">第六篇 容量管理概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/jiagoushisiweihetezhi/">第七篇 架构师思维和特质以及中间件技术梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/cicd/">第八篇 CICD流程概述</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/9_changkanchangxin/">第九篇 常看常新</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/12_monitor_and_alert/">第十二篇 监控报警最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_2/13_classic_thinkings/">第十三篇 经典思维</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第三章 Linux Net子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/1_linux_kernel_net/">第一篇 Linux数据包接收路径梳理和常用调优技能</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/2_estab_queue_monitoring/">第二篇 Linux下如何观察完整连接队列的情况</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/3_net_ipv4_tcp_syn_retries/">第三篇 理解net.ipv4.tcp_syn_retries设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/4_linux_kernel_net_v2/">第四篇 Linux网络数据包的揭秘以及常见的调优方式总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/5_conntrack/">第五篇 conntrack的常见应用</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/6_tcp/">第六篇 TCP协议总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/7_udp/">第七篇 UDP协议总结以及TCP和UDP的区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_3/8_io_multiplexing/">第八篇 IO多路复用总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第四章 Linux CPU子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/1_process_ulimit/">第一篇 进程Max open files的设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/2_pid_max/">第二篇 kernel源码中pid的最大值</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/3_interrupt_one/">第三篇 硬中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/5_soft_irq/">第四篇 软中断</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/4_process_thread_coroutine/">第五篇 进程、线程、协程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/6_cpu_famous_register/">第六篇 CPU中的著名寄存器梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/7_linux_signal/">第七篇 Linux信号机制</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/8_linux_scheduler/">第八篇 Linux进程调度</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/9_linux_arch_overall_introduction/">第九篇 Linux架构整体介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/10_linux_context_switch/">第十篇 低视角看context switch</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/11_linux_cpu_usage/">第十一篇 CPU利用率统计</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/12_linux_preemption/">第十二篇 内核抢占基础篇</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_4/13_interrupt_handler_examples/">第十三篇 中断处理程序的例子</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第五章 Linux IO子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/1_four_object_of_VFS/">第一篇 VFS四大对象inode、dentry、super_block、file数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/2_io_stack/">第二篇 Linux IO栈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/3_zero_copy/">第三篇 Linux 零拷贝技术总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/4_io_scheduler_layer/">第四篇 I/O调度层总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_5/5_fs_only_in_kernel/">第五篇 仅在内核空间可见的文件系统梳理</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第六章 Linux Mem子系统</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/1_linux_buddy/">第一篇 伙伴系统介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/2_slab/">第二篇 Slab层介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/3_virtual_memory/">第三篇 进程虚拟地址空间介绍</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/4_linux_mem_theory/">第四篇 Linux内存管理原理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/5_buffers_cached/">第五篇 Free命令中buffers和cached区别</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/6_alloc_mem_apis/">第六篇 Linux内核内存分配API函数分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_6/7_physical_memory/">第七篇 关于物理内存管理</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第七章 运维小技巧和工具汇总和积累</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/1_sync_file/">第一篇 不同主机之间的文件传输</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/2_sre_tools_python/">第二篇 运维生产力工具(python篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/3_sre_tools_website/">第三篇 运维生产力工具(网站工具)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/4_sre_tools_shell/">第四篇 运维生产力工具(shell篇)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/5_server_side_evolution/">第五篇 服务端进化过程梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/6_elk/">第六篇 elk技术栈</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/7_charset/">第七篇 字符集和编码</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/8_locale/">第八篇 locale设置</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/9_http_protocol/">第九篇 http协议</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_7/10_http_cookie_session_token/">第十篇 cookie和session和token总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第八章 职场通用经验</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/1_xuexixinde/">第一篇 学习心得和工作箴言</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/2_bangzhuqitatongxue/">第二篇 工作能力评价体系</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/3_yewuliuchengshuyu/">第三篇 项目管理总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/4_jishunenglimoxing/">第四篇 技术能力模型总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/5_chanpingsiwei_1/">第五篇 产品思维总结和梳理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/6_jixiaobaogao/">第六篇 如何写绩效报告</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/7_xiangshangguanli/">第七篇 如何向上管理</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/9_speaking_skills/">第九篇 沟通能力和演讲技巧</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/10_jixiaofangtan/">第十篇 绩效访谈总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_8/11_classic_technical_thinking/">第十一篇 经典技术思维汇总</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第九章 编程经验</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/1_suanfa/">第一篇 算法总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/2_data_structure/">第二篇 数据结构总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/3_c_lang/">第三篇 c语言总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_9/4_symbol_table/">第四篇 符号表总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十章 容器化和Kubernetes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/1_dockerfile_best_practice/">第一篇 dockerfile最佳实践</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/2_benefits_of_containerization/">第二篇 容器化的好处</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/3_docker_basic_concepts/">第三篇 一些基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/4_kubernetes_basic_concepts/">第四篇 Kubernetes基础概念</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/5_kubernetes_monitor/">第五篇 Kubernetes监控</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_10/6_production_kubernetes_best_practice/">第六篇 生产环境Kubernetes部署最佳实践</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十一章 SRE稳定性建设从理论到实践</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/1_theory/">第一篇 稳定性概论</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/10_high_avaliable/">第二篇 高可用原则总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/2_slo_process/">第三篇 SLO实施流程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/3_stress/">第四篇 压测经验总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_11/11_stability/">第五篇 稳定性理论总结</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十二章 商业化知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_12/1_shifouzhide/">第一篇 如何判断一件事情值不值得做</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十三章 芯片知识总结</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../chapter_13/1_about_riscv/">第一篇 RISC-V 简介</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">第十四章 Linux驱动方向总结</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../1_demo_of_led_driver/">第一篇 驱动程序的Hello World</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../2_qianrushidev/">第二篇 嵌入式开发基础</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../3_linux_kernel_api_list/">第三篇 Linux内核API汇总</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../4_zifushebeiqudongyuanli/">第四篇 字符设备驱动实现原理和物理内存地址空间和IO端口空间</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../5_device_tree/">第五篇 platform总线模型和设备树</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">第六篇 从阅读硬件手册开始设备驱动程序编写</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">一些基础知识</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1">1 基础知识</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-imx6ull-gpio">2 基于 I.MX6ULL 的 GPIO 配置流程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-imx6ull-io">3 I.MX6ULL 的寄存器和对应 IO 口的命名</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gpio">问题一 怎么找到对应 GPIO 的物理地址?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#imx6ull-">问题二 更多 I.MX6ULL 硬件知识 ---- 更多寄存器</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">各个寄存器含义</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">问题三 外设时钟使能</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gpio1_io03-io">问题四 配置 GPIO1_IO03 的 IO 属性</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#imx6ull-rom">问题五 I.MX6ULL ROM 程序启动之后, 其执行地址</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#linux">Linux 内核层面字符设备框架</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1_1">1 字符设备架构是如何实现的？</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-api">2 字符驱动相关内核 API</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_5">概要版本</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_6">详细</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3">3 如何编写字符设备驱动</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#1_2">1. 实现模块加载和卸载入口函数</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#2">2. 申请主设备号</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#3_1">3. 创建设备节点</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#4-file_operations">4. 实现 file_operations</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#5-cdev">5. 注册 cdev</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4">4 如何编写字符设备驱动整体视图</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5">5 代码示例</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../7_linux_kernel_clipping/">第七篇 Linux移植</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../8_linux_driver_framework/">第八篇 Linux驱动框架和SoC驱动框架</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../9_linux_device_class/">第九篇 Linux设备分类</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../10_u_boot/">第十篇 u-boot梳理和总结</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../13_embedded_development_direction/">第十三篇 嵌入式开发方向和分类</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Lott's Blog</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>第十四章 Linux驱动方向总结 &raquo;</li>
      <li>第六篇 从阅读硬件手册开始设备驱动程序编写</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1">概述</h1>
<blockquote>
<p>基于 I.MX6ULL 总结 LED 点灯程序, 从阅读硬件手册开始编写驱动程序.</p>
</blockquote>
<ul>
<li>本篇总结不同场景下驱动程序编写的步骤。</li>
<li>Linux 系统下编写驱动程序，最终本质都是操作寄存器, 但需要吃透其驱动框架.</li>
<li>
<ul>
<li>有点儿类似你写 Web 服务, 可以从 0 开始写一个 Web 服务, 也可以通过框架(比如 python 的 flask 框架)写一个 Web 服务.</li>
</ul>
</li>
</ul>
<h2 id="_2">一些基础知识</h2>
<h3 id="1">1 基础知识</h3>
<ul>
<li>首先, <code>IMX6ULL</code>有对应的手册, 分为<strong>参考手册</strong>和<strong>数据手册</strong></li>
<li>
<p>i.MX6ULL 有多种点灯方式：</p>
</li>
<li>
<ul>
<li>1 <strong>裸机系统</strong>：汇编操作寄存器点灯、C 语言操作寄存器点灯</li>
</ul>
</li>
<li>
<ul>
<li>2 <strong>跑 Linux 系统</strong>：字符驱动 LED 点灯、设备树驱动 LED 点灯</li>
</ul>
</li>
</ul>
<p>究其本质，最终都是要操作 i.MX6ULL 的寄存器。比如，在控制 GPIO 引脚实现 LED 亮灭时，会进行类似如下的寄存器配置：</p>
<pre><code>/* 寄存器物理地址 */
#define CCM_CCGR1_BASE              (0X020C406C)
#define SW_MUX_SNVS_TAMPER3_BASE    (0X02290014)
#define SW_PAD_SNVS_TAMPER3_BASE    (0X02290058)
#define GPIO5_DR_BASE               (0X020AC000)
#define GPIO5_GDIR_BASE             (0X020AC004)

</code></pre>
<ul>
<li>I.MX6U 的 GPIO 一共有 5 组:GPIO1、GPIO2、GPIO3、GPIO4 和 GPIO5, 其中每个组最多 32 个 IO 口.</li>
<li>
<ul>
<li>其中 GPIO1 有 32 个 IO，GPIO2 有 22 个 IO，GPIO3 有 29 个 IO、GPIO4 有 29 个 IO，GPIO5 最少，只有 12 个 IO，这样一共有 124 个 GPIO。</li>
</ul>
</li>
<li>
<ul>
<li>其中第一组 GPIO 的不同 IO 口命名方式为 GPIO1_IO00, GPIO1_IO01, GPIO1_IO02 以此类推.</li>
</ul>
</li>
</ul>
<h3 id="2-imx6ull-gpio">2 基于 I.MX6ULL 的 GPIO 配置流程</h3>
<ol>
<li>使能 GPIO 对应的时钟。</li>
<li>设置寄存器 IOMUXC_SW_MUX_CTL_PAD_XX_XX，设置 IO 的复用功能，使其改为 GPIO 功能。（比如 <code>IOMUXC_SW_MUX_CTL_PAD_JTAG_TRST_B</code> 这个 IO 口一共是 32 位，其中最低 4 位设置为 0101 即可将这个, 如果设置为其他值,则有其他不同的功能.)</li>
<li>设置寄存器 IOMUXC_SW_PAD_CTL_PAD_XX_XX，设置 IO 的上下拉、速度设置、驱动能力设置、压摆率设置等等。</li>
<li>第 2 步已经将 IO 改为了 GPIO 功能，所以需要配置 GPIO，设置输入/输出、是否使用中断、默认输出电平等。</li>
</ol>
<h3 id="3-imx6ull-io">3 I.MX6ULL 的寄存器和对应 IO 口的命名</h3>
<table>
<thead>
<tr>
<th>寄存器名称</th>
<th>IO 口名称</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SW_PAD_CTL_PAD_GPIO1_IO00 PAD Control Register</code></td>
<td><code>IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO00</code></td>
<td></td>
</tr>
<tr>
<td><code>SW_MUX_CTL_PAD_GPIO1_IO00 SW MUX Control Register</code></td>
<td><code>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00</code></td>
<td></td>
</tr>
<tr>
<td><code>SW_MUX_CTL_PAD_UART1_TX_DATA SW MUX Control Register</code></td>
<td><code>IOMUXC_SW_MUX_CTL_PAD_UART1_TX_DATA</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><img alt="png" src="../../img/WX20230515-094400222.png" /></p>
<ul>
<li>多个寄存器控制和配置<code>IO口</code>作用, 一个<code>IO口</code>对应一个<code>引脚</code>, 每个<code>引脚</code>可以连接一个<code>外设</code></li>
</ul>
<h2 id="gpio">问题一 怎么找到对应 GPIO 的物理地址?</h2>
<blockquote>
<p>查看对应的数据手册里对应端口的介绍, 其中有 Address, 如下图:</p>
</blockquote>
<p><img alt="png" src="../../img/WechatIMG226.jpeg" /></p>
<ul>
<li>
<p>I.MX6ULL 的 IO 分为两类:SNVS 域的和通用的 ----&gt; 为什么要这样分类?</p>
</li>
<li>
<p>更多 I.MX6ULL 硬件知识</p>
</li>
</ul>
<h2 id="imx6ull-">问题二 更多 I.MX6ULL 硬件知识 ---- 更多寄存器</h2>
<ul>
<li>
<p><code>SW_MUX_CTL_PAD**</code> 和 <code>SW_PAD_CTL_PAD**</code>两种寄存器用来设置 IO 的复用功能和 IO 属性 配置, 也就是我们通过设置上面这两种寄存器的不同值之后, 终于将某个 IO 口设置为了 GPIO 功能. 现在我们要接着来配置 GPIO 特有的寄存器了.</p>
</li>
<li>
<p>当 IO 用作 GPIO 的时候需要设置的寄存器，一共有八个: DR、GDIR、PSR、ICR1、ICR2、EDGE_SEL、IMR 和 ISR。前面我们说了 I.MX6U 一共有 GPIO1~GPIO5 共五组 GPIO，每组 GPIO 都有这 8 个寄存器。</p>
</li>
<li>
<ul>
<li>比如第一组 GPIO 的寄存器命名方式为 GPIO1.DR, 第二组 GPIO 的寄存器命名方式为 GPIO2.DR</li>
</ul>
</li>
<li>
<ul>
<li>由于每组 GPIO 最多 32 个 IO 口, 因此相应寄存器对应的位数也为 32 位, 每一位控制对应的 IO 口. 比如 GPIO2.DR 是 32 位寄存器、GPIO1.PSR 寄存器也是 32 位</li>
</ul>
</li>
</ul>
<h3 id="_3">各个寄存器含义</h3>
<ul>
<li>DR: 数据寄存器.</li>
<li>
<ul>
<li>比如方向寄存器设置为输出, 那么此时向数据寄存器输出 1 即可向对应 IO 口输出高电平, 输出 0 即可向对应 IO 口输出低电平.(其实就比较好控制 LED 灯这种简单设备的开或者关)</li>
</ul>
</li>
<li>
<ul>
<li>比如方向寄存器设置为输入, 那么此时就是通过读取寄存器的值获取对应 IO 口对应的电平值(是高电平还是低电平)</li>
</ul>
</li>
<li>GDIR: 方向寄存器, 设置某个 IO 口为输出电平或者输入电平.</li>
<li>PSR: 状态寄存器. 用于获取对应 IO 口的当前状态(当前是高电平或者低电平)</li>
<li>ICR1 和 ICR2: 这两个寄存器，都是中断控制寄存器，ICR1 用于配置低 16 个 IO, ICR2 用于配置高 16 个 IO, 也就是每 2 位配置一个 IO. 比如某个外设（比如键盘）可以上升沿触发中断.</li>
<li>IMR: 是中断屏蔽寄存器. IMR 寄存器也是一个 IO 对应一个位，IMR 寄存器用来设置 IO 的中断禁止和使能，如果使能某个 IO 的中断，那么设置相应的位为 1 即可，反之，如果要禁止中断，那么就设 置相应的位为 0 即可。例如，要使能 GPIO1_IO00 的中断，那么就可以设置 GPIO1.MIR=1 即 可。</li>
<li>ISR: 中断状态寄存器.</li>
<li>EDGE_SEL: 是边沿选择寄存器. EDGE_SEL 寄存器用来设置边沿中断，这个寄存器会覆盖 ICR1 和 ICR2 的设置，同样是一个 IO 对应一个位。如果相应的位被置 1，那么就相当与设置了对应的 IO 是上升沿和下降 沿(双边沿)触发。例如，我们设置 GPIO1.EDGE_SEL=1，那么就表示 GPIO1_IO01 是双边沿触 发中断，无论 GFPIO1_ICR1 的设置为多少，都是双边沿触发。</li>
</ul>
<h2 id="_4">问题三 外设时钟使能</h2>
<ul>
<li>I.MX6U 每个外设的时钟都可以独立的使能或禁止，这样可以关闭掉不使用的外设时钟，起到 省电的目的。</li>
<li>
<p>CCM 有 CCM_CCGR0~CCM_CCGR6 这 7 个寄存器，这 7 个寄存器控制着 I.MX6U 的所有外设时钟开关</p>
</li>
<li>
<p>根据 CCM_CCGR0 寄存器的使用说明, 我们发现如果我们要打开 GPIO2 的外设时钟，那么只需要设置
  CCM_CCGR0 的 bit31 和 bit30 都为 1 即可，也就是 CCM_CCGR0=3 &lt;&lt; 30。反之，如果要关闭 GPIO2 的外设时钟，那就设置 CCM_CCGR0 的 bit31 和 bit30 都为 0 即可。</p>
</li>
</ul>
<h2 id="gpio1_io03-io">问题四 配置 GPIO1_IO03 的 IO 属性</h2>
<ul>
<li>这么多<code>IO属性</code>是干嘛的?</li>
</ul>
<h2 id="imx6ull-rom">问题五 I.MX6ULL ROM 程序启动之后, 其执行地址</h2>
<ul>
<li>目前根据文档<strong>8.4.15</strong>来看, 启动之后 ROM 程序就会执行<code>0X87800000</code>这个地址的代码.</li>
</ul>
<h2 id="linux">Linux <a href="https://mp.weixin.qq.com/s/oIYQJbnVpiFqixNXWc_KMg">内核层面字符设备框架</a></h2>
<h3 id="1_1">1 字符设备架构是如何实现的？</h3>
<p>在 Linux 的世界里面一切皆文件，所有的硬件设备操作到应用层都会被抽象成文件的操作。我们知道如果应用层要访问硬件设备，它必定要调用到硬件对应的驱动程序。Linux 内核中有那么多驱动程序，应用层怎么才能精确的调用到底层的驱动程序呢？</p>
<p>在这里我们字符设备为例，来看一下应用程序是如何和底层驱动程序关联起来的。必须知道的基础知识：</p>
<p>1.在 Linux 文件系统中，每个文件都用一个<code>struct inode</code>结构体来描述，这个结构体里面记录了这个文件的所有信息，例如：文件类型，访问权限等。</p>
<p>2.在 Linux 操作系统中，每个驱动程序在应用层的/dev 目录下都会有一个设备文件和它对应，并且该文件会有对应的主设备号和次设备号。</p>
<p>3.在 Linux 操作系统中，每个驱动程序都要分配一个主设备号，字符设备的设备号保存在 struct cdev 结构体中。</p>
<pre><code>
 struct cdev {
        struct kobject kobj;
        struct module *owner;
        const struct file_operations *ops;//接口函数集合
        struct list_head list;//内核链表
        dev_t dev;    //设备号
        unsigned int count；//次设备号个数
    };

</code></pre>
<p>4.在 Linux 操作系统中，每打开一次文件，Linux 操作系统在<code>VFS层</code>都会分配一个<code>struct file</code>结构体来描述打开的这个文件。该结构体用于维护文件打开权限、文件指针偏移值、私有内存地址等信息。</p>
<p>注意：</p>
<p>常常我们认为<code>struct inode</code>描述的是文件的静态信息，即这些信息很少会改变。而<code>struct file</code>描述的是动态信息，即在对文件的操作的时候，<code>struct file</code>里面的信息经常会发生变化。典型的是<code>struct file</code>结构体里面的<code>f_pos(记录当前文件的位移量）</code>,每次读写一个普通文件时<code>f_ops</code>的值都会发生改变。</p>
<p>这几个结构体关系如下图所示：</p>
<p><img alt="png" src="../../img/WechatIMG245.jpeg" /></p>
<p>通过上图我们可以知道，如果想访问底层设备，就必须打开对应的设备文件。也就是在这个打开的过程中，Linux 内核将应用层和对应的驱动程序关联起来。</p>
<p>1.当 open 函数打开设备文件时，可以根据设备文件对应的 struct inode 结构体描述的信息，可以知道接下来要操作的设备类型（字符设备还是块设备）。还会分配一个 struct file 结构体。</p>
<p>2.根据 struct inode 结构体里面记录的设备号，可以找到对应的驱动程序。这里以字符设备为例。在 Linux 操作系统中每个字符设备有一个 struct cdev 结构体。此结构体描述了字符设备所有的信息，其中最重要一项的就是字符设备的操作函数接口。</p>
<p>3.找到 struct cdev 结构体后，Linux 内核就会将 struct cdev 结构体所在的内存空间首地记录在 struct inode 结构体的 i_cdev 成员中。将 struct cdev 结构体的中记录的函数操作接口地址记录在 struct file 结构体的 f_op 成员中。</p>
<p>4.任务完成，VFS 层会给应用层返回一个文件描述符（fd)。这个 fd 是和 struct file 结构体对应的。接下来上层的应用程序就可以通过 fd 来找到 strut file,然后在由 struct file 找到操作字符设备的函数接口了。</p>
<h3 id="2-api">2 字符驱动相关内核 API</h3>
<h4 id="_5">概要版本</h4>
<ul>
<li>申请设备号: <code>alloc_chrdev_region()</code> </li>
<li>
<p>占用设备号: ``</p>
</li>
<li>
<p>设备号是dev_t类型, 本质是一个int类型. 该类型前几位代表MAJOR，后几位代表MINOR</p>
</li>
<li><code>MAJOR()</code>和<code>MINOR()</code> ---&gt; 这两个宏可以从dev_t类型获取主设备号和次设备号. </li>
<li>初始化cdev: <code>cdev_init()</code></li>
<li>注册cdev: <code>cdev_add()</code></li>
<li><code>class_create()</code>在sysfs中创建类</li>
<li><code>device_create()</code>在devfs中创建设备</li>
<li>如果使用<code>register_chrdev()</code> API, 则可以免去<code>cdev_init</code>和<code>cdev_add</code>过程</li>
<li>register_chrdev如果是入参为0, 则会动态注册设备号dev_t. </li>
<li>register_chrdev_region是静态注册设备号, 也就是说先人工定义设备号然后用register_chrdev_region去注册. 可能出现失败的情况. 加个判断，出现失败的时候就调用alloc_chrdev_region动态申请设备号.</li>
<li>register_chrdev内部也会初始化cdev,并进行cdev_add, 然后会调用__register_chrdev_region静态注册设备号. 并且register_chrdev是相对比较老的版本的内核的做法, 理论上现在更加推荐走的新的做法.</li>
</ul>
<h4 id="_6">详细</h4>
<ul>
<li><code>cdev_init()</code></li>
</ul>
<pre><code>

/**
 * cdev_init() - initialize a cdev structure
 * @cdev: the structure to initialize
 * @fops: the file_operations for this device
 *
 * Initializes @cdev, remembering @fops, making it ready to add to the
 * system with cdev_add().
 */
void cdev_init(struct cdev *cdev, const struct file_operations *fops)
功能：
  初始化cdev结构体
参数：
  @cdev cdev结构体地址
  @fops 操作字符设备的函数接口地址
返回值：
  无

</code></pre>
<ul>
<li><code>register_chrdev_region()</code></li>
</ul>
<pre><code>
/**
 * register_chrdev_region() - register a range of device numbers
 * @from: the first in the desired range of device numbers; must include
 *        the major number.
 * @count: the number of consecutive device numbers required
 * @name: the name of the device or driver.
 *
 * Return value is zero on success, a negative error code on failure.
 */
int register_chrdev_region(dev_t from, unsigned count, const char *name)
功能：
  注册一个范围（)的设备号
参数：
  @from 设备号
  @count 注册的设备个数
  @name 设备的名字
返回值：
  成功返回0,失败返回错误码（负数）

</code></pre>
<ul>
<li><code>cdev_add()</code></li>
</ul>
<pre><code>
/**
 * cdev_add() - add a char device to the system
 * @p: the cdev structure for the device
 * @dev: the first device number for which this device is responsible
 * @count: the number of consecutive minor numbers corresponding to this
 *         device
 *
 * cdev_add() adds the device represented by @p to the system, making it
 * live immediately.  A negative error code is returned on failure.
 */
int cdev_add(struct cdev *p, dev_t dev, unsigned count)
功能：
  添加一个字符设备到操作系统
参数：
  @p cdev结构体地址
  @dev 设备号
  @count 次设备号个数
返回值：
  成功返回0,失败返回错误码（负数）

</code></pre>
<ul>
<li><code>cdev_del()</code></li>
</ul>
<pre><code>
/**
 * cdev_del() - remove a cdev from the system
 * @p: the cdev structure to be removed
 *
 * cdev_del() removes @p from the system, possibly freeing the structure
 * itself.
 */
void cdev_del(struct cdev *p)
功能：
  从系统中删除一个字符设备
参数：
  @p cdev结构体地址
返回值：
  无

</code></pre>
<ul>
<li><code>register_chrdev()</code></li>
</ul>
<pre><code>
static inline int register_chrdev(unsigned int major, const char *name,
          const struct file_operations *fops)

功能：
  注册或者分配设备号，并注册fops到cdev结构体，
  如果major&gt;0，功能为注册该主设备号，
  如果major=0，功能为动态分配主设备号。
参数：
  @major : 主设备号
  @name : 设备名称，执行 cat /proc/devices显示的名称
  @fops  : 文件系统的接口指针
返回值
  如果major&gt;0   成功返回0，失败返回负的错误码
  如果major=0  成功返回主设备号，失败返回负的错误码
该函数实现了对cdev的初始化和注册的封装，所以调用该函数之后就不需要自己操作cdev了。

</code></pre>
<ul>
<li>相对的注销函数为<code>unregister_chrdev()</code></li>
</ul>
<pre><code>

static inline void unregister_chrdev(unsigned int major, const char *name)

</code></pre>
<h3 id="3">3 如何编写字符设备驱动</h3>
<p><img alt="png" src="../../img/WechatIMG246.jpeg" /></p>
<blockquote>
<p>参考上图，编写字符设备驱动步骤如下：</p>
</blockquote>
<h4 id="1_2">1. 实现模块加载和卸载入口函数</h4>
<pre><code>
module_init (hello_init);
module_exit (hello_exit);

</code></pre>
<h4 id="2">2. 申请主设备号</h4>
<p>申请主设备号 (内核中用于区分和管理不同字符设备)</p>
<pre><code>
register_chrdev_region (devno, number_of_devices, &quot;hello&quot;);

</code></pre>
<h4 id="3_1">3. 创建设备节点</h4>
<p>创建设备节点文件 (为用户提供一个可操作到文件接口--open()) 创建设备节点有两种方式：手动方式创建，函数自动创建。</p>
<h6 id="31">3.1 手动创建：</h6>
<pre><code>
mknod /dev/hello c 250 0

</code></pre>
<h6 id="32-udev">3.2 自动创建设备节点(udev 机制)</h6>
<p>除了使用 mknod 命令手动创建设备节点，还可以利用 linux 的 <code>udev、mdev 机制</code>，
busybox 会创建一个 udev 的简化版本--mdev
而我们的 ARM 开发板上移植的 <strong>busybox 有 mdev 机制</strong>，那么就使用 mdev 机制来自动创建设备节点。</p>
<p>在 etc/init.d/rcS 文件里有一句：</p>
<pre><code>
echo /sbin/mdev &gt; /proc/sys/kernel/hotplug

</code></pre>
<p>该命令就是用来自动创建设备节点。</p>
<p>udev 是一个工作在用户空间的工具，它能根据系统中硬件设备的状态动态的更新设备文件，包括设备文件的创建，删除，权限等。这些文件通常都定义在/dev 目录下，但也可以在配置文件中指定。udev 必须有内核中的 sysfs 和 tmpfs 支持，sysfs 为 udev 提供设备入口和 uevent 通道，tmpfs 为 udev 设备文件提供存放空间。</p>
<p>udev 运行在用户模式，而非内核中。udev 的初始化脚本在系统启动时创建设备节点，并且当插入新设备——加入驱动模块——在 sysfs 上注册新的数据后，udev 会创新新的设备节点。</p>
<blockquote>
<p>注意，udev 是通过对内核产生的设备文件修改，或增加别名的方式来达到自定义设备文件的目的。但是，udev 是用户模式程序，其不会更改内核行为。也就是说，内核仍然会创建 sda，sdb 等设备文件，而 udev 可根据设备的唯一信息来区分不同的设备，并产生新的设备文件（或链接）。</p>
</blockquote>
<h6 id="33-sys">3.3 如何在/sys 虚拟文件系统下创建设备分类</h6>
<ol>
<li>第一步 ：通过宏<code>class_create()</code> 创建一个 class 类型的对象；</li>
</ol>
<pre><code>
/* This is a #define to keep the compiler from merging different
 * instances of the __key variable */
#define class_create(owner, name)    \
({            \
  static struct lock_class_key __key;  \
  __class_create(owner, name, &amp;__key);  \
})

参数：
  @owner  THIS_MODULE
  @name   类名字
返回值
  可以定义一个struct class的指针变量cls接受返回值，然后通过IS_ERR(cls)判断
  是否失败，如果成功这个宏返回0，失败返回非9值（可以通过PTR_ERR(cls)来获得
  失败返回的错误码）

</code></pre>
<p>在 Linux 内核中，把设备进行了分类，同一类设备可以放在同一个目录下，该函数启示就是创建了一个类，例如：</p>
<p><img alt="png" src="../../img/WechatIMG247.jpeg" /></p>
<ol>
<li>第二步：导出我们的设备信息到用户空间</li>
</ol>
<pre><code>
/**
 * device_create - creates a device and registers it with sysfs
 * @class: pointer to the struct class that this device should be registered to
 * @parent: pointer to the parent struct device of this new device, if any
 * @devt: the dev_t for the char device to be added
 * @drvdata: the data to be added to the device for callbacks
 * @fmt: string for the device's name
 *
 * This function can be used by char device classes.  A struct device
 * will be created in sysfs, registered to the specified class.
 *
 * A &quot;dev&quot; file will be created, showing the dev_t for the device, if
 * the dev_t is not 0,0.
 * If a pointer to a parent struct device is passed in, the newly created
 * struct device will be a child of that device in sysfs.
 * The pointer to the struct device will be returned from the call.
 * Any further sysfs files that might be required can be created using this
 * pointer.
 *
 * Returns &amp;struct device pointer on success, or ERR_PTR() on error.
 *
 * Note: the struct class passed to this function must have previously
 * been created with a call to class_create().
 */
struct device *device_create(struct class *class, struct device *parent,
           dev_t devt, void *drvdata, const char *fmt, ...)
自动创建设备节点使用实例：

static struct class *cls;
static struct device *test_device;

  devno = MKDEV(major,minor);
  cls = class_create(THIS_MODULE,&quot;helloclass&quot;);
  if(IS_ERR(cls))
  {
    unregister_chrdev(major,&quot;hello&quot;);
    return result;
  }
  test_device = device_create(cls,NULL,devno,NULL,&quot;hellodevice&quot;);
  if(IS_ERR(test_device ))
  {
    class_destroy(cls);
    unregister_chrdev(major,&quot;hello&quot;);
    return result;
  }

</code></pre>
<h4 id="4-file_operations">4. 实现 file_operations</h4>
<pre><code>
static const struct file_operations fifo_operations = {
.owner = THIS_MODULE,
.open = dev_fifo_open,
.read = dev_fifo_read,
.write = dev_fifo_write,
.unlocked_ioctl = dev_fifo_unlocked_ioctl,
};

</code></pre>
<h5 id="ioctl">关于 ioctl 的展开</h5>
<h6 id="1-xxx_ioctl">(1)为什么要实现 xxx_ioctl ?</h6>
<p>前面我们在驱动中已经实现了读写接口，通过这些接口我们可以完成对设备的读写。但是很多时候我们的应用层工程师除了要对设备进行读写数据之外，还希望可以对设备进行控制。例如:针对串口设备，驱动层除了需要提供对串口的读写之外，还需提供对串口波特率、奇偶校验位、终止位的设置，这些配置信息需要从应用层传递一些基本数据，仅仅是数据类型不同。</p>
<p>通过 xxx_ioctl 函数接口，可以提供对设备的控制能力,增加驱动程序的灵活性。</p>
<h6 id="2-xxx_ioctl">(2)如何实现 xxx_ioctl 函数接口?</h6>
<p>增加 xxx_ioctl 函数接口，应用层可以通过 ioctl 系统调用，根据不同的命令来操作 dev_fifo。</p>
<p>kernel 2.6.35 及之前的版本中 struct file_operations 一共有 3 个 ioctl ：ioctl,unlocked_ioctl 和 compat_ioctl 现在只有 unlocked_ioctl 和 compat_ioctl 了</p>
<p>在 kernel 2.6.36 中已经完全删除了 struct file_operations 中的 ioctl 函数指针，取而代之的是 unlocked_ioctl 。</p>
<p>· 2.6.36 之前的内核</p>
<pre><code>
long (ioctl) (struct inode node ,struct file* filp, unsigned int cmd,unsigned long arg)

</code></pre>
<p>· 2.6.36 之后的内核</p>
<pre><code>
long (*unlocked_ioctl) (struct file *filp, unsigned int cmd, unsigned long arg)

</code></pre>
<p>参数 cmd: 通过应用函数 ioctl 传递下来的命令</p>
<p>先来看看应用层的 ioctl 和驱动层的 xxx_ioctl 对应关系:</p>
<p><img alt="png" src="../../img/WechatIMG249.jpeg" /></p>
<h4 id="5-cdev">5. 注册 cdev</h4>
<p>定义好<code>file_operations</code>结构体，就可以通过函数<code>cdev_init()</code>、<code>cdev_add()</code>注册字符设备驱动了。</p>
<p>实例如下：</p>
<pre><code>
static struct cdev cdev;

cdev_init(&amp;cdev,&amp;hello_ops);
error = cdev_add(&amp;cdev,devno,1);

</code></pre>
<blockquote>
<p>注意如果使用了函数<code>register_chrdev()</code>,就不用了执行上述操作，因为该函数已经实现了对 cdev 的封装。</p>
</blockquote>
<h3 id="4">4 如何编写字符设备驱动整体视图</h3>
<p><img alt="png" src="../../img/WechatIMG248.jpeg" /></p>
<h3 id="5">5 代码示例</h3>
<p>好了，现在我们可以来实现一个完整的字符设备框架的实例，包括打开、关闭、读写、ioctrl、自动创建设备节点等功能。</p>
<pre><code>
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &quot;dev_fifo_head.h&quot;

//指定的主设备号
#define   MAJOR_NUM 250

//自己的字符设备
struct mycdev
{
    int len;
    unsigned   char buffer[50];
    struct   cdev cdev;
};

MODULE_LICENSE(&quot;GPL&quot;);
//设备号
static dev_t   dev_num = {0};
//全局gcd
struct mycdev *gcd;
//设备类
struct class *cls;
//获得用户传递的数据，根据它来决定注册的设备个数
static int ndevices = 1;
module_param(ndevices, int, 0644);
MODULE_PARM_DESC(ndevices, &quot;The number of devices for register.\n&quot;);

//打开设备
static int dev_fifo_open(struct   inode *inode,   struct file *file)
{
    struct   mycdev *cd;

    printk(&quot;dev_fifo_open   success!\n&quot;);
    //用struct file的文件私有数据指针保存struct mycdev结构体指针
    cd   = container_of(inode-&gt;i_cdev,struct   mycdev,cdev);
    file-&gt;private_data =   cd;
    return   0;
}

//读设备
static ssize_t   dev_fifo_read(struct file *file, char   __user *ubuf,   size_t
size, loff_t *ppos)
{
    int n;
    int ret;
    char   *kbuf;
    struct   mycdev *mycd =   file-&gt;private_data;

    printk(&quot;read *ppos :   %lld\n&quot;,*ppos);

    if(*ppos == mycd-&gt;len)
        return   0;

    //请求大大小 &gt; buffer剩余的字节数   :读取实际记得字节数
    if(size &gt; mycd-&gt;len - *ppos)
        n = mycd-&gt;len - *ppos;
    else
        n = size;

    printk(&quot;n =   %d\n&quot;,n);
    //从上一次文件位置指针的位置开始读取数据
    kbuf   = mycd-&gt;buffer   + *ppos;
    //拷贝数据到用户空间
    ret   = copy_to_user(ubuf,kbuf, n);
    if(ret != 0)
        return   -EFAULT;

    //更新文件位置指针的值
    *ppos += n;
    printk(&quot;dev_fifo_read   success!\n&quot;);
    return   n;
}
//写设备
static ssize_t   dev_fifo_write(struct file *file, const char __user *ubuf,size_t size, loff_t *ppos)
{
    int n;
    int ret;
    char   *kbuf;
    struct   mycdev *mycd =   file-&gt;private_data;

    printk(&quot;write *ppos :   %lld\n&quot;,*ppos);
    //已经到达buffer尾部了
    if(*ppos == sizeof(mycd-&gt;buffer))
       return   -1;
    //请求大大小 &gt; buffer剩余的字节数(有多少空间就写多少数据)
    if(size &gt; sizeof(mycd-&gt;buffer) - *ppos)
        n = sizeof(mycd-&gt;buffer) - *ppos;
    else
        n = size;
    //从上一次文件位置指针的位置开始写入数据

    kbuf   = mycd-&gt;buffer   + *ppos;
    //拷贝数据到内核空间
    ret   = copy_from_user(kbuf, ubuf, n);
    if(ret != 0)
        return   -EFAULT;

    //更新文件位置指针的值
    *ppos += n;
    //更新dev_fifo.len
    mycd-&gt;len += n;
    printk(&quot;dev_fifo_write   success!\n&quot;);
    return   n;
}

//linux 内核在2.6以后，已经废弃了ioctl函数指针结构，取而代之的是

long   dev_fifo_unlocked_ioctl(struct file *file,   unsigned int cmd,
    unsigned   long arg)
{
  int ret = 0;
  struct mycdev *mycd   = file-&gt;private_data;

  if(_IOC_TYPE(cmd)!=DEV_FIFO_TYPE){
    pr_err(&quot;cmd   %u,bad magic 0x%x/0x%x.\n&quot;,cmd,_IOC_TYPE(cmd),DEV_FIFO_TYPE);
    return-ENOTTY;
  }
  if(_IOC_DIR(cmd)&amp;_IOC_READ)
    ret=!access_ok(VERIFY_WRITE,(void __user*)arg,_IOC_SIZE(cmd));
  else if( _IOC_DIR(cmd)&amp;_IOC_WRITE )
    ret=!access_ok(VERIFY_READ,(void   __user*)arg,_IOC_SIZE(cmd));
  if(ret){
    pr_err(&quot;bad   access %ld.\n&quot;,ret);
    return-EFAULT;
  }
    switch(cmd)
    {
      case DEV_FIFO_CLEAN:
         printk(&quot;CMD:CLEAN\n&quot;);
      memset(mycd-&gt;buffer, 0, sizeof(mycd-&gt;buffer));
         break;
      case DEV_FIFO_SETVALUE:
         printk(&quot;CMD:SETVALUE\n&quot;);
         mycd-&gt;len = arg;
         break;
      case DEV_FIFO_GETVALUE:
         printk(&quot;CMD:GETVALUE\n&quot;);
         ret   = put_user(mycd-&gt;len, (int *)arg);
         break;
      default:
         return   -EFAULT;
    }
    return   ret;
}

//设备操作函数接口

static const struct file_operations fifo_operations = {
    .owner =   THIS_MODULE,
    .open =   dev_fifo_open,
    .read =   dev_fifo_read,
    .write =   dev_fifo_write,
    .unlocked_ioctl =   dev_fifo_unlocked_ioctl,
};
//模块入口
int __init dev_fifo_init(void)
{
    int i = 0;
    int n = 0;
    int ret;

    struct   device *device;
  gcd   = kzalloc(ndevices   * sizeof(struct   mycdev), GFP_KERNEL);

    if(!gcd){
        return   -ENOMEM;
    }

    //设备号 : 主设备号(12bit) | 次设备号(20bit)
    dev_num   = MKDEV(MAJOR_NUM, 0);
    //静态注册设备号
    ret   = register_chrdev_region(dev_num,ndevices,&quot;dev_fifo&quot;);
    if(ret &lt; 0){
    //静态注册失败，进行动态注册设备号
     ret   =alloc_chrdev_region(&amp;dev_num,0,ndevices,&quot;dev_fifo&quot;);
      if(ret &lt; 0){
        printk(&quot;Fail to register_chrdev_region\n&quot;);
        goto   err_register_chrdev_region;
      }
    }
    //创建设备类
    cls   = class_create(THIS_MODULE, &quot;dev_fifo&quot;);
    if(IS_ERR(cls)){
        ret   = PTR_ERR(cls);
        goto   err_class_create;
    }
    printk(&quot;ndevices :   %d\n&quot;,ndevices);
    for(n = 0;n &lt; ndevices;n   ++)
    {
      //初始化字符设备
      cdev_init(&amp;gcd[n].cdev,&amp;fifo_operations);
      //添加设备到操作系统
      ret   = cdev_add(&amp;gcd[n].cdev,dev_num + n,1);
      if (ret &lt; 0)
      {
         goto   err_cdev_add;
      }
     //导出设备信息到用户空间(/sys/class/类名/设备名)
      device   = device_create(cls,NULL,dev_num +n,NULL,&quot;dev_fifo%d&quot;,n);
      if(IS_ERR(device)){
         ret   = PTR_ERR(device);
         printk(&quot;Fail to device_create\n&quot;);
         goto   err_device_create;
      }
    }
    printk(&quot;Register   dev_fito to system,ok!\n&quot;);
    return   0;
err_device_create:

    //将已经导出的设备信息除去
    for(i = 0;i &lt; n;i ++)
    {
       device_destroy(cls,dev_num + i);
    }
err_cdev_add:
    //将已经添加的全部除去
    for(i = 0;i &lt; n;i ++)
    {
       cdev_del(&amp;gcd[i].cdev);
    }
err_class_create:
    unregister_chrdev_region(dev_num,   ndevices);
err_register_chrdev_region:
    return   ret;
}
void __exit dev_fifo_exit(void)
{
    int i;
    //删除sysfs文件系统中的设备
    for(i = 0;i &lt; ndevices;i   ++)
    {
        device_destroy(cls,dev_num + i);
    }
    //删除系统中的设备类
    class_destroy(cls);
    //从系统中删除添加的字符设备
    for(i = 0;i &lt; ndevices;i   ++)
    {
       cdev_del(&amp;gcd[i].cdev);
    }
    //释放申请的设备号
    unregister_chrdev_region(dev_num,   ndevices);
    return;
}
module_init(dev_fifo_init);
module_exit(dev_fifo_exit);

</code></pre>
<p>头文件内容:</p>
<p>dev_fifo_head.h</p>
<pre><code>
#ifndef _DEV_FIFO_HEAD_H
#define _DEV_FIFO_HEAD_H
#define DEV_FIFO_TYPE 'k'
#define DEV_FIFO_CLEAN _IO(DEV_FIFO_TYPE,0x10)
#define DEV_FIFO_GETVALUE _IOR(DEV_FIFO_TYPE,0x11,int)
#define DEV_FIFO_SETVALUE _IOW(DEV_FIFO_TYPE,0x12,int)
#endif

</code></pre>
<p>Makefile :</p>
<pre><code>
ifeq ($(KERNELRELEASE),)
KERNEL_DIR ?=/lib/modules/$(shell uname -r)/build
PWD :=$(shell pwd)
modules:
    $(MAKE) -C $(KERNEL_DIR)   M=$(PWD) modules
.PHONY:modules clean
clean:
    $(MAKE) -C $(KERNEL_DIR)   M=$(PWD) clean
else
    obj-m := dev_fifo.o
endif

</code></pre>
<p>应用程序:</p>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, const char *argv[])
{
    int fd ;
    int n;
    char buf[1024] = &quot;hello   word&quot;;

    fd = open(&quot;/dev/dev_fifo0&quot;,O_RDWR);
    if(fd &lt; 0){
        perror(&quot;Fail   ot open&quot;);
        return   -1;
    }
    printf(&quot;open   successful ,fd = %d\n&quot;,fd);
    n = write(fd,buf,strlen(buf));
    if(n &lt; 0){
        perror(&quot;Fail   to write&quot;);
        return   -1;
    }
    printf(&quot;write   %d bytes!\n&quot;,n);
    n = write(fd,buf,strlen(buf));
    if(n &lt; 0){
        perror(&quot;Fail   to write&quot;);
        return   -1;
    }
    printf(&quot;write   %d bytes!\n&quot;,n);
    return 0;
}

</code></pre>
<p>测试步骤：</p>
<ul>
<li>（1） 加载模块</li>
</ul>
<p><code>sudo insmod hello.ko</code></p>
<ul>
<li>（2） 创建设备节点</li>
</ul>
<p><code>sudo mknod /dev/hello c 250 0</code></p>
<p>如果代码中增加了自动创建设备节点的功能，这个步骤不要执行。</p>
<ul>
<li>（3） 测试字符设备</li>
</ul>
<pre><code>
gcc test.c -o run
sudo ./run

</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../5_device_tree/" class="btn btn-neutral float-left" title="第五篇 platform总线模型和设备树"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../7_linux_kernel_clipping/" class="btn btn-neutral float-right" title="第七篇 Linux移植">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../5_device_tree/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../7_linux_kernel_clipping/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
